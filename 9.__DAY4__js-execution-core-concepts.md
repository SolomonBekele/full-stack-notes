# JavaScript Execution & Core Concepts

## Table of Contents
1. [JS Engine & Execution Context](#js-engine--execution-context)
2. [Call Stack & Memory Model](#call-stack--memory-model)
3. [Event Loop](#event-loop)
4. [Variable Declarations (let, const, var) and Hoisting](#variable-declarations-let-const-var-and-hoisting)
5. [Temporal Dead Zone (TDZ)](#temporal-dead-zone-tdz)
6. [Immutability vs Mutability (Primitives vs References)](#immutability-vs-mutability-primitives-vs-references)
7. [Shallow Copy vs Deep Copy](#shallow-copy-vs-deep-copy)
8. [Best Practices in Variable Management](#best-practices-in-variable-management)
9. [Summary](#summary)

## JS Engine & Execution Context

JavaScript engines (like V8 in Chrome, SpiderMonkey in Firefox) are responsible for parsing, compiling, and executing JS code. The process involves:
- **Parsing:** Source code is converted into an Abstract Syntax Tree (AST).
- **Compilation:** Modern engines use Just-In-Time (JIT) compilation for performance.
- **Execution:** Code runs in an environment called the execution context.

**Types of Execution Contexts:**
- **Global Context:** Created when the script starts; contains global variables and functions.
- **Function Context:** Created whenever a function is invoked; has its own scope and `this` binding.
- **Eval Context:** Created by the `eval()` function (rarely used).

Each context has:
- **Variable Environment:** Where variables/functions are stored.
- **Lexical Environment:** Tracks variable scope and closures.
- **`this` Binding:** Depends on how a function is called.

[refer this video](https://www.youtube.com/watch?v=uH-tVP8MUs8)

## Call Stack & Memory Model

The call stack is a data structure (LIFO) that tracks function calls:
- Each function call creates a stack frame with local variables and parameters.
- When a function returns, its frame is popped off the stack.

**Memory Model:**
- **Stack:** Stores primitives and function call frames (fast access, limited size).
- **Heap:** Stores objects, arrays, and functions (dynamic size, slower access).
- **Garbage Collection:** JS automatically frees memory that's no longer referenced.

**Example:**
```js
function foo() {
  let x = 10;
  bar();
}
function bar() {
  let y = 20;
}
foo(); // Call stack: foo -> bar
```

## Event Loop

JavaScript is single-threaded, but it handles asynchronous operations using the event loop. The event loop enables non-blocking behavior by managing tasks, microtasks, and rendering:
- **Call Stack:** Executes synchronous code.
- **Web APIs:** Browser-provided APIs (e.g., setTimeout, fetch) handle async operations outside the stack.
- **Callback Queue (Task Queue):** Stores callbacks from async operations (timers, I/O, etc.).
- **Microtask Queue:** Stores microtasks (Promise callbacks, MutationObserver).
- **Event Loop:** Continuously checks if the call stack is empty, then pushes tasks from the microtask queue (first) and callback queue (next) onto the stack.

**Order of Execution:**
1. Execute all synchronous code on the call stack.
2. Process all microtasks (Promises, etc.) before moving to the next task.
3. Render UI updates.
4. Process the next task from the callback queue.

**Example:**
```js
console.log('A');
setTimeout(() => console.log('B'), 0);
Promise.resolve().then(() => console.log('C'));
console.log('D');
// Output: A, D, C, B
```

**Why?**
- 'A' and 'D' are synchronous.
- Promise microtask ('C') runs before the timer task ('B').

**Implications:**
- Understanding the event loop is crucial for writing efficient async code and avoiding race conditions.
- Use microtasks for critical updates, tasks for less urgent work.

## Variable Declarations (let, const, var) and Hoisting

- **`var`:** Function-scoped, hoisted and initialized as `undefined`. Can be redeclared and updated.
- **`let`:** Block-scoped, hoisted but not initialized (TDZ applies). Cannot be redeclared in the same scope.
- **`const`:** Block-scoped, must be initialized, cannot be reassigned. The value itself can be mutable if it's an object.

**Hoisting Example:**
```js
console.log(a); // undefined
var a = 5;

console.log(b); // ReferenceError
let b = 10;
```

## Temporal Dead Zone (TDZ)

The TDZ is the period between entering scope and variable initialization for `let` and `const`:
- Accessing the variable before its declaration throws a ReferenceError.
- Prevents accidental usage of uninitialized variables.

**Example:**
```js
{
  // TDZ for 'x' starts here
  // console.log(x); // ReferenceError
  let x = 2; // TDZ ends
}
```

## Immutability vs Mutability (Primitives vs References)

- **Primitives:** (string, number, boolean, null, undefined, symbol, bigint) are immutable. Changing a primitive creates a new value.
- **Reference Types:** (object, array, function) are mutable. Modifying a property affects all references to that object.

**Example:**
```js
let a = 1;
let b = a;
a = 2;
console.log(b); // 1 (primitive, copy by value)

let obj1 = { val: 1 };
let obj2 = obj1;
obj1.val = 2;
console.log(obj2.val); // 2 (reference, copy by reference)
```

## Shallow Copy vs Deep Copy

- **Shallow Copy:** Copies only the top-level properties. Nested objects are still shared.
  - Methods: `Object.assign()`, spread operator (`...`).
- **Deep Copy:** Recursively copies all nested objects. No shared references.
  - Methods: `structuredClone()`, `JSON.parse(JSON.stringify(obj))`, custom recursion.

**Example:**
```js
const original = { user: { name: 'Alice' } };
const shallow = { ...original };
shallow.user.name = 'Bob';
console.log(original.user.name); // 'Bob' (shallow copy)

const deep = structuredClone(original);
deep.user.name = 'Charlie';
console.log(original.user.name); // 'Bob' (deep copy)
```

**Implications:**
- Shallow copy can cause bugs in UI state management (e.g., React) if nested objects are mutated.
- Deep copy is safer for immutable state updates.

## Best Practices in Variable Management

- Prefer `const` for values that shouldn't change.
- Use `let` for variables that will be reassigned.
- Avoid `var` due to hoisting and scope confusion.
- Always initialize variables when declared.
- Use deep copy for state management in UI frameworks.
- Avoid mutating objects directly; use immutable patterns.
- Name variables clearly and consistently.
- Limit variable scope to where it's needed.

**Scenario:**
- In UI frameworks (like React), shallow copy can cause bugs if you mutate nested state. Always use deep copy for complex state updates.

---

**Summary:**
Understanding execution context, event loop, variable scope, and copy behavior is essential for writing robust JavaScript, especially in modern UI frameworks. Use best practices to avoid common pitfalls and write maintainable code.
