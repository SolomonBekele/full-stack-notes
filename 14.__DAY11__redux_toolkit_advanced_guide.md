# Redux Toolkit Advanced Guide

## Table of Contents
1. [Redux Core Concepts & Flow](#redux-core-concepts--flow)
2. [Redux Toolkit Fundamentals](#redux-toolkit-fundamentals)
3. [Advanced RTK Query](#advanced-rtk-query)
4. [Custom Middleware with RTK](#custom-middleware-with-rtk)
5. [Performance Optimization](#performance-optimization)
6. [Advanced State Management Patterns](#advanced-state-management-patterns)
7. [Testing Strategies](#testing-strategies)
8. [TypeScript Integration](#typescript-integration)
9. [Real-world Architecture](#real-world-architecture)

## Redux Core Concepts & Flow

### Redux Data Flow Diagram
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Component     â”‚â”€â”€â”€â”€â”‚     Action      â”‚â”€â”€â”€â”€â”‚   Dispatcher    â”‚
â”‚                 â”‚    â”‚   {type, data}  â”‚    â”‚                 â”‚
â”‚ onClick={() =>  â”‚    â”‚                 â”‚    â”‚ store.dispatch â”‚
â”‚ dispatch(action)â”‚    â”‚ ADD_TODO        â”‚    â”‚   (action)      â”‚
â”‚ }               â”‚    â”‚ {text: "Buy"}   â”‚    â”‚                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â–²                                               â”‚
         â”‚                                               â–¼
         â”‚                                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚                                    â”‚     Store       â”‚
         â”‚                                    â”‚                 â”‚
         â”‚                                    â”‚ Current State   â”‚
         â”‚                                    â”‚ + Reducer       â”‚
         â”‚                                    â”‚ = New State     â”‚
         â”‚                                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                                               â”‚
         â”‚                                               â–¼
         â”‚                                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚                                    â”‚    Reducer      â”‚
         â”‚                                    â”‚                 â”‚
         â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ (state, action) â”‚
                                              â”‚ => newState     â”‚
                                              â”‚                 â”‚
                                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Redux Principles Flow
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SINGLE SOURCE OF TRUTH                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚                    STORE                                â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚    â”‚
â”‚  â”‚  â”‚    Auth     â”‚  â”‚    Posts    â”‚  â”‚     UI      â”‚      â”‚    â”‚
â”‚  â”‚  â”‚   State     â”‚  â”‚   State     â”‚  â”‚   State     â”‚      â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
                                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    STATE IS READ-ONLY                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Component â”€â”€â–º Action â”€â”€â–º Dispatcher â”€â”€â–º Store                  â”‚
â”‚      â”‚                                     â”‚                   â”‚
â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚               (Subscribe to changes)                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
                                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              CHANGES WITH PURE FUNCTIONS                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚                   REDUCER                               â”‚    â”‚
â”‚  â”‚                                                         â”‚    â”‚
â”‚  â”‚  function reducer(state, action) {                      â”‚    â”‚
â”‚  â”‚    switch(action.type) {                                â”‚    â”‚
â”‚  â”‚      case 'ADD_TODO':                                   â”‚    â”‚
â”‚  â”‚        return {                                         â”‚    â”‚
â”‚  â”‚          ...state,                                      â”‚    â”‚
â”‚  â”‚          todos: [...state.todos, action.payload]       â”‚    â”‚
â”‚  â”‚        }                                                â”‚    â”‚
â”‚  â”‚      default:                                           â”‚    â”‚
â”‚  â”‚        return state                                     â”‚    â”‚
â”‚  â”‚    }                                                    â”‚    â”‚
â”‚  â”‚  }                                                      â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Redux Middleware Flow
```
Action â†’ Middleware 1 â†’ Middleware 2 â†’ ... â†’ Reducer â†’ Store
   â–²                                                      â”‚
   â”‚                                                      â–¼
Component â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Subscribe â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ New State

Detailed Middleware Chain:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Action    â”‚â”€â”€â”€â–ºâ”‚   Logger    â”‚â”€â”€â”€â–ºâ”‚   Thunk     â”‚â”€â”€â”€â–ºâ”‚   Reducer   â”‚
â”‚             â”‚    â”‚ Middleware  â”‚    â”‚ Middleware  â”‚    â”‚             â”‚
â”‚ {type: 'X'} â”‚    â”‚ (log action)â”‚    â”‚ (handle     â”‚    â”‚ (update     â”‚
â”‚             â”‚    â”‚             â”‚    â”‚  async)     â”‚    â”‚  state)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```



## Redux Middleware Concepts

### What is Redux Middleware?

Redux middleware provides a third-party extension point between dispatching an action and the moment it reaches the reducer. Middleware is composable and can be used for logging, crash reporting, talking to an asynchronous API, routing, and more.

### Middleware Execution Flow
```
Action Dispatched
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Middleware 1  â”‚ â”€â”€â–º Can modify, delay, or cancel action
â”‚   (Logger)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Middleware 2  â”‚ â”€â”€â–º Can dispatch new actions
â”‚   (Thunk)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Middleware 3  â”‚ â”€â”€â–º Can access current state
â”‚   (Analytics)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Reducer      â”‚ â”€â”€â–º Pure function that updates state
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   New State     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Middleware Signature
```javascript
// Basic middleware structure
const middleware = (store) => (next) => (action) => {
  // Before action reaches reducer
  console.log('Dispatching action:', action)
  console.log('Current state:', store.getState())
  
  // Call the next middleware or reducer
  const result = next(action)
  
  // After action has been processed
  console.log('New state:', store.getState())
  
  return result
}

// Curried function breakdown:
// store => { dispatch, getState }
// next => function to call next middleware
// action => the action being dispatched
```

### Common Middleware Types

#### 1. Logger Middleware
```javascript
const loggerMiddleware = (store) => (next) => (action) => {
  const startTime = Date.now()
  
  console.group(`ðŸ”„ Action: ${action.type}`)
  console.log('ðŸ“¤ Action:', action)
  console.log('ðŸ“Š Previous State:', store.getState())
  
  const result = next(action)
  
  const endTime = Date.now()
  console.log('ðŸ“ˆ Next State:', store.getState())
  console.log(`â±ï¸ Duration: ${endTime - startTime}ms`)
  console.groupEnd()
  
  return result
}
```

#### 2. Thunk Middleware (Async Actions)
```javascript
const thunkMiddleware = (store) => (next) => (action) => {
  // If action is a function, call it with dispatch and getState
  if (typeof action === 'function') {
    return action(store.dispatch, store.getState)
  }
  
  // Otherwise, pass action to next middleware
  return next(action)
}

// Usage with thunk
const fetchUser = (userId) => {
  return async (dispatch, getState) => {
    dispatch({ type: 'FETCH_USER_PENDING' })
    
    try {
      const response = await api.getUser(userId)
      dispatch({ type: 'FETCH_USER_SUCCESS', payload: response.data })
    } catch (error) {
      dispatch({ type: 'FETCH_USER_ERROR', payload: error.message })
    }
  }
}
```

#### 3. Error Handling Middleware
```javascript
const errorMiddleware = (store) => (next) => (action) => {
  try {
    return next(action)
  } catch (error) {
    console.error('ðŸ’¥ Redux Error:', error)
    
    // Dispatch error action
    store.dispatch({
      type: 'GLOBAL_ERROR',
      payload: {
        message: error.message,
        action: action.type,
        timestamp: new Date().toISOString()
      }
    })
    
    // Report to error tracking service
    errorTracker.captureException(error, {
      extra: {
        action,
        state: store.getState()
      }
    })
    
    return error
  }
}
```

#### 4. Analytics Middleware
```javascript
const analyticsMiddleware = (store) => (next) => (action) => {
  const result = next(action)
  
  // Track specific user actions
  const trackableActions = [
    'USER_LOGIN',
    'POST_CREATED',
    'PURCHASE_COMPLETED',
    'BUTTON_CLICKED'
  ]
  
  if (trackableActions.includes(action.type)) {
    analytics.track(action.type, {
      payload: action.payload,
      userId: store.getState().user?.id,
      timestamp: Date.now(),
      sessionId: store.getState().session?.id
    })
  }
  
  return result
}
```

### Middleware Composition
```javascript
// How middleware is composed in Redux
const middlewareChain = [
  loggerMiddleware,
  thunkMiddleware,
  errorMiddleware,
  analyticsMiddleware
]

// Internal Redux composition (simplified)
function applyMiddleware(...middlewares) {
  return (createStore) => (reducer, preloadedState) => {
    const store = createStore(reducer, preloadedState)
    
    let dispatch = store.dispatch
    const middlewareAPI = {
      getState: store.getState,
      dispatch: (action) => dispatch(action)
    }
    
    const chain = middlewares.map(middleware => middleware(middlewareAPI))
    dispatch = compose(...chain)(store.dispatch)
    
    return {
      ...store,
      dispatch
    }
  }
}

// Execution flow with multiple middleware:
// Action â†’ Logger â†’ Thunk â†’ Error â†’ Analytics â†’ Reducer
```

### RTK and Middleware

Redux Toolkit includes several middleware by default:
```javascript
import { configureStore } from '@reduxjs/toolkit'

const store = configureStore({
  reducer: rootReducer,
  // Default middleware includes:
  // - thunk (for async actions)
  // - immutableCheck (warns about mutations)
  // - serializableCheck (warns about non-serializable values)
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      // Customize default middleware
      thunk: {
        extraArgument: { api, router }
      },
      serializableCheck: {
        ignoredActions: ['persist/PERSIST', 'persist/REHYDRATE']
      }
    }).concat(
      // Add custom middleware
      loggerMiddleware,
      analyticsMiddleware
    )
})
```

### Middleware Best Practices

1. **Keep middleware pure** - Don't mutate actions or state
2. **Handle errors gracefully** - Wrap middleware logic in try-catch
3. **Optimize performance** - Avoid expensive operations in hot paths
4. **Use middleware for cross-cutting concerns** - Logging, analytics, persistence
5. **Order matters** - Place middleware in correct sequence
6. **Environment-specific middleware** - Different middleware for dev/prod

## Significance of Redux Middleware

### Why Middleware is Critical for Redux Applications

Redux middleware is one of the most powerful and essential concepts in the Redux ecosystem. It provides extensibility and enables sophisticated application architectures while maintaining Redux's core principles.

### Value Proposition of Middleware

#### 1. **Separation of Concerns**
```
Without Middleware:                    With Middleware:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Component     â”‚                   â”‚   Component     â”‚
â”‚                 â”‚                   â”‚                 â”‚
â”‚ â€¢ Business Logicâ”‚                   â”‚ â€¢ UI Logic Only â”‚
â”‚ â€¢ API Calls     â”‚    â”€â”€â”€â”€â”€â”€â”€â”€â–º      â”‚ â€¢ Pure Actions  â”‚
â”‚ â€¢ Logging       â”‚                   â”‚                 â”‚
â”‚ â€¢ Error Handlingâ”‚                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚ â€¢ Analytics     â”‚                            â”‚
â”‚ â€¢ Validation    â”‚                            â–¼
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                      â”‚   Middleware    â”‚
                                      â”‚                 â”‚
                                      â”‚ â€¢ Cross-cutting â”‚
                                      â”‚   Concerns      â”‚
                                      â”‚ â€¢ Reusable      â”‚
                                      â”‚ â€¢ Testable      â”‚
                                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 2. **Cross-Cutting Concerns Management**
Middleware handles application-wide concerns that would otherwise be scattered across components:

```typescript
// Without middleware - scattered logging
const LoginComponent = () => {
  const handleLogin = async (credentials) => {
    console.log('Login attempt started', credentials.email) // Scattered
    
    try {
      const result = await authAPI.login(credentials)
      console.log('Login successful', result.user.id) // Scattered
      dispatch(setUser(result.user))
    } catch (error) {
      console.error('Login failed', error.message) // Scattered
    }
  }
}

// With middleware - centralized logging
const loggerMiddleware = (store) => (next) => (action) => {
  console.log(`Action: ${action.type}`, action.payload)
  const result = next(action)
  console.log('New state:', store.getState())
  return result
}
// All components automatically get logging without any changes!
```

#### 3. **Composable Architecture**
Middleware enables building applications as a composition of independent, reusable pieces:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Middleware Stack                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚  â”‚   Logger    â”‚â†’ â”‚   Thunk     â”‚â†’ â”‚ Analytics   â”‚â†’ Reducer     â”‚
â”‚  â”‚             â”‚  â”‚             â”‚  â”‚             â”‚              â”‚
â”‚  â”‚ â€¢ Dev only  â”‚  â”‚ â€¢ Async     â”‚  â”‚ â€¢ Tracking  â”‚              â”‚
â”‚  â”‚ â€¢ Debug     â”‚  â”‚ â€¢ Side      â”‚  â”‚ â€¢ Metrics   â”‚              â”‚
â”‚  â”‚ â€¢ Audit     â”‚  â”‚   effects   â”‚  â”‚ â€¢ Events    â”‚              â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Each middleware can be:
â€¢ Developed independently
â€¢ Tested in isolation
â€¢ Reused across projects
â€¢ Added/removed without affecting others
```

### Key Values Middleware Brings

#### 1. **Async Operation Management**
```typescript
// Before Redux Thunk middleware
const Component = () => {
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState(null)
  
  const fetchData = async () => {
    setLoading(true)
    setError(null)
    
    try {
      const data = await api.fetchData()
      dispatch({ type: 'SET_DATA', payload: data })
    } catch (err) {
      setError(err.message)
    } finally {
      setLoading(false)
    }
  }
}

// After Redux Thunk middleware
const fetchData = createAsyncThunk('data/fetch', async () => {
  return await api.fetchData()  // Automatic loading/error handling
})

// Component becomes much simpler
const Component = () => {
  const { data, loading, error } = useSelector(state => state.data)
  // Middleware handles all async complexity!
}
```

#### 2. **Development Experience Enhancement**
```typescript
// Redux DevTools middleware provides:
â€¢ Time-travel debugging
â€¢ Action replay
â€¢ State inspection
â€¢ Performance monitoring
â€¢ Hot reloading support

// Logger middleware provides:
â€¢ Action tracing
â€¢ State diff visualization
â€¢ Performance metrics
â€¢ Error debugging context
```

#### 3. **Production Monitoring & Analytics**
```typescript
const productionMiddleware = (store) => (next) => (action) => {
  // Performance monitoring
  const start = performance.now()
  const result = next(action)
  const duration = performance.now() - start
  
  // Send metrics to monitoring service
  if (duration > 100) {
    monitoring.reportSlowAction(action.type, duration)
  }
  
  // Business analytics
  if (action.type === 'PURCHASE_COMPLETED') {
    analytics.track('purchase', {
      amount: action.payload.amount,
      userId: store.getState().user.id
    })
  }
  
  // Error tracking
  if (action.type.endsWith('/rejected')) {
    errorReporting.captureException(action.error)
  }
  
  return result
}
```

#### 4. **Security & Authorization**
```typescript
const securityMiddleware = (store) => (next) => (action) => {
  const state = store.getState()
  
  // Automatic token refresh
  if (action.type.startsWith('api/') && isTokenExpired(state.auth.token)) {
    store.dispatch(refreshToken())
  }
  
  // Permission checking
  if (action.type.startsWith('admin/') && !hasAdminRole(state.user)) {
    return // Block unauthorized actions
  }
  
  // Audit logging
  if (SENSITIVE_ACTIONS.includes(action.type)) {
    auditLogger.log({
      action: action.type,
      userId: state.user.id,
      timestamp: Date.now(),
      metadata: action.meta
    })
  }
  
  return next(action)
}
```

### Business Impact of Middleware

#### **1. Reduced Development Time**
- **Code Reusability**: Write once, use everywhere
- **Faster Debugging**: Centralized logging and error handling
- **Simplified Testing**: Mock middleware instead of scattered logic

#### **2. Improved Code Quality**
- **Consistent Patterns**: Standardized cross-cutting concerns
- **Better Separation**: UI logic separate from business logic
- **Maintainability**: Changes in one place affect entire app

#### **3. Enhanced User Experience**
- **Performance Monitoring**: Identify and fix slow operations
- **Error Recovery**: Graceful error handling and retry logic
- **Optimistic Updates**: Immediate UI feedback

#### **4. Operational Excellence**
- **Observability**: Comprehensive logging and metrics
- **Security**: Centralized authentication and authorization
- **Scalability**: Modular architecture supports growth

### Real-World Impact Examples

#### E-commerce Application
```typescript
// Middleware stack for e-commerce
const ecommerceMiddleware = [
  authMiddleware,        // Handle token refresh
  cartMiddleware,        // Sync cart with server
  analyticsMiddleware,   // Track user behavior
  performanceMiddleware, // Monitor page load times
  errorMiddleware,       // Report checkout failures
  auditMiddleware       // Log financial transactions
]

// Business benefits:
â€¢ 40% reduction in cart abandonment (optimistic updates)
â€¢ 60% faster bug resolution (comprehensive logging)
â€¢ 25% increase in conversion (performance monitoring)
â€¢ 100% audit compliance (automatic transaction logging)
```

#### Social Media Platform
```typescript
const socialMediaMiddleware = [
  realTimeMiddleware,    // WebSocket connections
  moderationMiddleware,  // Content filtering
  cacheMiddleware,       // Offline support
  feedMiddleware,        // Personalized content
  notificationMiddleware // Push notifications
]

// Business benefits:
â€¢ Real-time user engagement
â€¢ Automated content moderation
â€¢ Offline-first experience
â€¢ Personalized user feeds
â€¢ Timely notifications
```

### Middleware vs Alternatives

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Middleware vs Other Patterns                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Higher-Order Components (HOCs):                                â”‚
â”‚  âŒ Component-specific                                           â”‚
â”‚  âŒ Hard to compose                                              â”‚
â”‚  âŒ Props drilling                                               â”‚
â”‚                                                                 â”‚
â”‚  Custom Hooks:                                                  â”‚
â”‚  âŒ Component-level only                                         â”‚
â”‚  âŒ No action interception                                       â”‚
â”‚  âŒ Limited composability                                        â”‚
â”‚                                                                 â”‚
â”‚  Redux Middleware:                                              â”‚
â”‚  âœ… Application-wide                                             â”‚
â”‚  âœ… Highly composable                                            â”‚
â”‚  âœ… Action-level control                                         â”‚
â”‚  âœ… Framework agnostic                                           â”‚
â”‚  âœ… Testable in isolation                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Redux middleware is not just a nice-to-have featureâ€”it's a fundamental architectural pattern that enables scalable, maintainable, and robust applications. It transforms Redux from a simple state management tool into a comprehensive application framework.

## Redux Toolkit Fundamentals

### Redux Toolkit Benefits Over Plain Redux
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Plain Redux      â”‚              â”‚   Redux Toolkit     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤              â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                     â”‚              â”‚                     â”‚
â”‚ â€¢ Boilerplate Heavy â”‚    â”€â”€â”€â”€â–º     â”‚ â€¢ Minimal Boiler.   â”‚
â”‚ â€¢ Manual Immutable  â”‚              â”‚ â€¢ Immer Built-in    â”‚
â”‚ â€¢ Configure Store   â”‚              â”‚ â€¢ configureStore()  â”‚
â”‚ â€¢ DevTools Setup    â”‚              â”‚ â€¢ DevTools Default  â”‚
â”‚ â€¢ Thunk Setup       â”‚              â”‚ â€¢ Thunk Included    â”‚
â”‚ â€¢ Action Creators   â”‚              â”‚ â€¢ createSlice()     â”‚
â”‚ â€¢ Switch Statements â”‚              â”‚ â€¢ Auto Actions      â”‚
â”‚ â€¢ Type Safety Hard  â”‚              â”‚ â€¢ TS First-class    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### createSlice Flow Diagram
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        createSlice()                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Input: {name, initialState, reducers, extraReducers}          â”‚
â”‚                                â”‚                                â”‚
â”‚                                â–¼                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚                   Processing                            â”‚    â”‚
â”‚  â”‚                                                         â”‚    â”‚
â”‚  â”‚  â€¢ Generate action creators                             â”‚    â”‚
â”‚  â”‚  â€¢ Generate action types                                â”‚    â”‚
â”‚  â”‚  â€¢ Create reducer function                              â”‚    â”‚
â”‚  â”‚  â€¢ Add Immer for immutability                           â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                â”‚                                â”‚
â”‚                                â–¼                                â”‚
â”‚  Output: {actions, reducer, name, getInitialState}             â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Example Flow:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ counterSlice.   â”‚â”€â”€â”€â–ºâ”‚ Action Creator  â”‚â”€â”€â”€â–ºâ”‚ Reducer Updates â”‚
â”‚ actions.        â”‚    â”‚                 â”‚    â”‚                 â”‚
â”‚ increment()     â”‚    â”‚ {type:          â”‚    â”‚ state.value++   â”‚
â”‚                 â”‚    â”‚ 'counter/       â”‚    â”‚ (via Immer)     â”‚
â”‚                 â”‚    â”‚  increment'}    â”‚    â”‚                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### createAsyncThunk Flow
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    createAsyncThunk Lifecycle                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Component Dispatch
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    pending      â”‚ â”€â”€â–º { type: 'users/fetchUser/pending' }
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Async Function â”‚
â”‚   Execution     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â–¼
    Success? â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€ Yes â”€â”€â–º â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚          â”‚            â”‚    fulfilled    â”‚
        â”‚          â”‚            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚          â”‚
        â”‚          â””â”€â”€â”€ No â”€â”€â”€â–º â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                       â”‚    rejected     â”‚
        â”‚                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ State Updated   â”‚
â”‚ in extraReducersâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

State Transitions:
Loading: false â†’ true â†’ false
Error: null â†’ null/error message
Data: null â†’ null/data
```

### RTK Query Architecture
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      RTK Query Flow                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Component
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Generated Hook â”‚â”€â”€â”€â–ºâ”‚   Cache Check   â”‚â”€â”€â”€â–ºâ”‚  Server Call?   â”‚
â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚
â”‚ useGetUserQuery â”‚    â”‚ Is data fresh?  â”‚    â”‚ Yes â”‚    No     â”‚
â”‚    (userId)     â”‚    â”‚ Is it cached?   â”‚    â”‚  â”‚  â”‚     â”‚     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”¼â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”˜
                                                 â”‚  â”‚     â”‚
                                                 â–¼  â”‚     â–¼
                                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  Return
                                        â”‚ API Call    â”‚  Cached
                                        â”‚             â”‚  Data
                                        â”‚ baseQuery + â”‚
                                        â”‚ transform   â”‚
                                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                 â”‚
                                                 â–¼
                                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                        â”‚Update Cache â”‚
                                        â”‚& Normalize  â”‚
                                        â”‚             â”‚
                                        â”‚Invalidate   â”‚
                                        â”‚Tags if neededâ”‚
                                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Cache Structure:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Cache Slices                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  api: {                                                         â”‚
â”‚    queries: {                                                   â”‚
â”‚      'getUser(1)': {                                            â”‚
â”‚        status: 'fulfilled',                                     â”‚
â”‚        data: { id: 1, name: 'John' },                          â”‚
â”‚        requestId: 'abc123',                                     â”‚
â”‚        startedTimeStamp: 1627846261721                          â”‚
â”‚      }                                                          â”‚
â”‚    },                                                           â”‚
â”‚    mutations: {                                                 â”‚
â”‚      'updateUser(1)': { ... }                                  â”‚
â”‚    },                                                           â”‚
â”‚    provided: {                                                  â”‚
â”‚      User: {                                                    â”‚
â”‚        '1': ['getUser(1)', 'updateUser(1)']                    â”‚
â”‚      }                                                          â”‚
â”‚    }                                                            â”‚
â”‚  }                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Redux Toolkit Step-by-Step Setup Guide

### Step 1: Installation and Project Setup

#### Install Redux Toolkit
```bash
# Using npm
npm install @reduxjs/toolkit react-redux

# Using yarn
yarn add @reduxjs/toolkit react-redux

# For TypeScript projects
npm install @reduxjs/toolkit react-redux @types/react-redux
```

#### Project Structure Setup
```
src/
  store/
    index.ts                # Store configuration
    hooks.ts               # Typed hooks
  features/
    auth/
      authSlice.ts         # Auth slice
      authAPI.ts           # RTK Query API
    posts/
      postsSlice.ts        # Posts slice
      postsAPI.ts          # RTK Query API
  App.tsx
  index.tsx
```

### Step 2: Configure the Store

#### Basic Store Setup
```typescript
// src/store/index.ts
import { configureStore } from '@reduxjs/toolkit'
import { authSlice } from '../features/auth/authSlice'
import { postsSlice } from '../features/posts/postsSlice'
import { authAPI } from '../features/auth/authAPI'
import { postsAPI } from '../features/posts/postsAPI'

export const store = configureStore({
  reducer: {
    auth: authSlice.reducer,
    posts: postsSlice.reducer,
    // Add RTK Query API reducers
    authAPI: authAPI.reducer,
    postsAPI: postsAPI.reducer,
  },
  // RTK includes Redux Thunk by default
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      // Configure serialization checks
      serializableCheck: {
        ignoredActions: ['persist/PERSIST', 'persist/REHYDRATE'],
      },
    })
    // Add RTK Query middleware
    .concat(authAPI.middleware)
    .concat(postsAPI.middleware),
  
  // Enable Redux DevTools in development
  devTools: process.env.NODE_ENV !== 'production',
})

export type RootState = ReturnType<typeof store.getState>
export type AppDispatch = typeof store.dispatch
```

#### Setup Typed Hooks
```typescript
// src/store/hooks.ts
import { useDispatch, useSelector, TypedUseSelectorHook } from 'react-redux'
import type { RootState, AppDispatch } from './index'

// Use throughout your app instead of plain `useDispatch` and `useSelector`
export const useAppDispatch = () => useDispatch<AppDispatch>()
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector
```

### Step 3: Create Reducers with createSlice

#### Basic Slice Creation
```typescript
// src/features/auth/authSlice.ts
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit'

// Define the state type
interface AuthState {
  user: User | null
  token: string | null
  loading: boolean
  error: string | null
  isAuthenticated: boolean
}

// Initial state
const initialState: AuthState = {
  user: null,
  token: localStorage.getItem('token'),
  loading: false,
  error: null,
  isAuthenticated: false,
}

// Async thunk for login
export const loginUser = createAsyncThunk(
  'auth/loginUser',
  async (credentials: LoginCredentials, { rejectWithValue }) => {
    try {
      const response = await authAPI.login(credentials)
      // Store token in localStorage
      localStorage.setItem('token', response.data.token)
      return response.data
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.message || 'Login failed')
    }
  }
)

// Create the slice
export const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    // Synchronous reducers
    logout: (state) => {
      state.user = null
      state.token = null
      state.isAuthenticated = false
      localStorage.removeItem('token')
    },
    clearError: (state) => {
      state.error = null
    },
    setCredentials: (state, action: PayloadAction<{user: User, token: string}>) => {
      state.user = action.payload.user
      state.token = action.payload.token
      state.isAuthenticated = true
    },
  },
  extraReducers: (builder) => {
    // Handle async thunk states
    builder
      .addCase(loginUser.pending, (state) => {
        state.loading = true
        state.error = null
      })
      .addCase(loginUser.fulfilled, (state, action) => {
        state.loading = false
        state.user = action.payload.user
        state.token = action.payload.token
        state.isAuthenticated = true
        state.error = null
      })
      .addCase(loginUser.rejected, (state, action) => {
        state.loading = false
        state.error = action.payload as string
        state.isAuthenticated = false
      })
  },
})

// Export actions and reducer
export const { logout, clearError, setCredentials } = authSlice.actions
export default authSlice.reducer

// Selectors
export const selectCurrentUser = (state: RootState) => state.auth.user
export const selectIsAuthenticated = (state: RootState) => state.auth.isAuthenticated
export const selectAuthLoading = (state: RootState) => state.auth.loading
export const selectAuthError = (state: RootState) => state.auth.error
```

### Step 4: Setup Middleware with Thunk (Advanced Usage)

#### Custom Async Thunks with Extra Arguments
```typescript
// Configure store with extra thunk arguments
export const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      thunk: {
        extraArgument: {
          api: apiClient,
          router: history,
        },
      },
    }),
})

// Use extra arguments in thunks
export const fetchUserProfile = createAsyncThunk(
  'user/fetchProfile',
  async (userId: string, { getState, dispatch, extra, rejectWithValue }) => {
    const { api } = extra as { api: ApiClient, router: any }
    const state = getState() as RootState
    
    // Access current state
    const currentUser = state.auth.user
    
    try {
      // Use API client from extra arguments
      const response = await api.getUserProfile(userId)
      
      // Dispatch other actions if needed
      dispatch(updateLastActivity())
      
      return response.data
    } catch (error: any) {
      return rejectWithValue(error.message)
    }
  }
)
```

#### Complex Async Logic with Multiple Dispatches
```typescript
export const handleUserRegistration = createAsyncThunk(
  'auth/registerUser',
  async (userData: RegisterData, { dispatch, rejectWithValue }) => {
    try {
      // Step 1: Register user
      dispatch(setRegistrationStep('creating_account'))
      const registerResponse = await authAPI.register(userData)
      
      // Step 2: Send verification email
      dispatch(setRegistrationStep('sending_verification'))
      await authAPI.sendVerificationEmail(registerResponse.data.email)
      
      // Step 3: Setup user preferences
      dispatch(setRegistrationStep('setting_preferences'))
      await userAPI.setupDefaultPreferences(registerResponse.data.id)
      
      // Step 4: Complete registration
      dispatch(setRegistrationStep('completed'))
      
      return {
        user: registerResponse.data,
        message: 'Registration completed successfully'
      }
    } catch (error: any) {
      dispatch(setRegistrationStep('failed'))
      return rejectWithValue(error.response?.data?.message || 'Registration failed')
    }
  }
)
```

### Step 5: Dispatch Actions in Components

#### Basic Action Dispatching
```typescript
// src/components/LoginForm.tsx
import React, { useState } from 'react'
import { useAppDispatch, useAppSelector } from '../store/hooks'
import { loginUser, clearError } from '../features/auth/authSlice'

const LoginForm: React.FC = () => {
  const dispatch = useAppDispatch()
  const { loading, error, isAuthenticated } = useAppSelector((state) => state.auth)
  
  const [credentials, setCredentials] = useState({
    email: '',
    password: ''
  })

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    
    // Clear any previous errors
    dispatch(clearError())
    
    // Dispatch async thunk
    const result = await dispatch(loginUser(credentials))
    
    // Check if login was successful
    if (loginUser.fulfilled.match(result)) {
      console.log('Login successful:', result.payload)
      // Redirect or update UI
    } else {
      console.error('Login failed:', result.payload)
    }
  }

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setCredentials({
      ...credentials,
      [e.target.name]: e.target.value
    })
  }

  // Handle loading and error states
  if (loading) return <div>Logging in...</div>
  if (isAuthenticated) return <div>Welcome back!</div>

  return (
    <form onSubmit={handleSubmit}>
      {error && <div className="error">{error}</div>}
      
      <input
        type="email"
        name="email"
        value={credentials.email}
        onChange={handleInputChange}
        placeholder="Email"
        required
      />
      
      <input
        type="password"
        name="password"
        value={credentials.password}
        onChange={handleInputChange}
        placeholder="Password"
        required
      />
      
      <button type="submit" disabled={loading}>
        {loading ? 'Logging in...' : 'Login'}
      </button>
    </form>
  )
}
```

#### Advanced Component with Multiple Actions
```typescript
// src/components/PostManager.tsx
import React, { useEffect } from 'react'
import { useAppDispatch, useAppSelector } from '../store/hooks'
import { 
  fetchPosts, 
  createPost, 
  updatePost, 
  deletePost,
  selectAllPosts,
  selectPostsLoading
} from '../features/posts/postsSlice'

const PostManager: React.FC = () => {
  const dispatch = useAppDispatch()
  const posts = useAppSelector(selectAllPosts)
  const loading = useAppSelector(selectPostsLoading)
  
  useEffect(() => {
    // Fetch posts on component mount
    dispatch(fetchPosts())
  }, [dispatch])

  const handleCreatePost = async () => {
    const newPost = {
      title: 'New Post',
      content: 'Post content',
      authorId: 'user123'
    }
    
    try {
      const result = await dispatch(createPost(newPost)).unwrap()
      console.log('Post created:', result)
    } catch (error) {
      console.error('Failed to create post:', error)
    }
  }

  const handleUpdatePost = async (postId: string, updates: Partial<Post>) => {
    try {
      await dispatch(updatePost({ id: postId, updates })).unwrap()
    } catch (error) {
      console.error('Failed to update post:', error)
    }
  }

  const handleDeletePost = async (postId: string) => {
    if (window.confirm('Are you sure you want to delete this post?')) {
      try {
        await dispatch(deletePost(postId)).unwrap()
      } catch (error) {
        console.error('Failed to delete post:', error)
      }
    }
  }

  if (loading) return <div>Loading posts...</div>

  return (
    <div>
      <button onClick={handleCreatePost}>Create Post</button>
      
      {posts.map(post => (
        <div key={post.id}>
          <h3>{post.title}</h3>
          <p>{post.content}</p>
          <button onClick={() => handleUpdatePost(post.id, { title: 'Updated Title' })}>
            Update
          </button>
          <button onClick={() => handleDeletePost(post.id)}>
            Delete
          </button>
        </div>
      ))}
    </div>
  )
}
```

### Step 6: Setup RTK Query

#### Create API Slice
```typescript
// src/features/posts/postsAPI.ts
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'
import type { RootState } from '../../store'

// Define types
interface Post {
  id: string
  title: string
  content: string
  authorId: string
  createdAt: string
  updatedAt: string
}

interface CreatePostRequest {
  title: string
  content: string
  authorId: string
}

interface UpdatePostRequest {
  id: string
  title?: string
  content?: string
}

// Create API slice
export const postsAPI = createApi({
  reducerPath: 'postsAPI',
  baseQuery: fetchBaseQuery({
    baseUrl: '/api/posts/',
    prepareHeaders: (headers, { getState }) => {
      // Add auth token to headers
      const token = (getState() as RootState).auth.token
      if (token) {
        headers.set('authorization', `Bearer ${token}`)
      }
      return headers
    },
  }),
  tagTypes: ['Post', 'PostList'],
  endpoints: (builder) => ({
    // Get all posts
    getPosts: builder.query<Post[], { page?: number; limit?: number }>({
      query: ({ page = 1, limit = 10 } = {}) => `?page=${page}&limit=${limit}`,
      providesTags: (result) =>
        result
          ? [
              ...result.map(({ id }) => ({ type: 'Post' as const, id })),
              { type: 'PostList', id: 'LIST' },
            ]
          : [{ type: 'PostList', id: 'LIST' }],
    }),
    
    // Get single post
    getPost: builder.query<Post, string>({
      query: (id) => `${id}`,
      providesTags: (result, error, id) => [{ type: 'Post', id }],
    }),
    
    // Create post
    createPost: builder.mutation<Post, CreatePostRequest>({
      query: (newPost) => ({
        url: '',
        method: 'POST',
        body: newPost,
      }),
      invalidatesTags: [{ type: 'PostList', id: 'LIST' }],
      // Optimistic update
      onQueryStarted: async (newPost, { dispatch, queryFulfilled }) => {
        const patchResult = dispatch(
          postsAPI.util.updateQueryData('getPosts', {}, (draft) => {
            draft.push({
              ...newPost,
              id: `temp-${Date.now()}`,
              createdAt: new Date().toISOString(),
              updatedAt: new Date().toISOString(),
            } as Post)
          })
        )
        
        try {
          await queryFulfilled
        } catch {
          patchResult.undo()
        }
      },
    }),
    
    // Update post
    updatePost: builder.mutation<Post, UpdatePostRequest>({
      query: ({ id, ...patch }) => ({
        url: `${id}`,
        method: 'PATCH',
        body: patch,
      }),
      invalidatesTags: (result, error, { id }) => [{ type: 'Post', id }],
      // Optimistic update
      onQueryStarted: async ({ id, ...patch }, { dispatch, queryFulfilled }) => {
        const patchResult = dispatch(
          postsAPI.util.updateQueryData('getPost', id, (draft) => {
            Object.assign(draft, patch)
          })
        )
        
        try {
          await queryFulfilled
        } catch {
          patchResult.undo()
        }
      },
    }),
    
    // Delete post
    deletePost: builder.mutation<{ success: boolean; id: string }, string>({
      query: (id) => ({
        url: `${id}`,
        method: 'DELETE',
      }),
      invalidatesTags: (result, error, id) => [
        { type: 'Post', id },
        { type: 'PostList', id: 'LIST' },
      ],
    }),
  }),
})

// Export hooks for use in components
export const {
  useGetPostsQuery,
  useGetPostQuery,
  useCreatePostMutation,
  useUpdatePostMutation,
  useDeletePostMutation,
} = postsAPI
```

#### Using RTK Query in Components
```typescript
// src/components/PostsList.tsx
import React, { useState } from 'react'
import {
  useGetPostsQuery,
  useCreatePostMutation,
  useUpdatePostMutation,
  useDeletePostMutation,
} from '../features/posts/postsAPI'

const PostsList: React.FC = () => {
  const [page, setPage] = useState(1)
  const [newPostTitle, setNewPostTitle] = useState('')
  
  // RTK Query hooks
  const {
    data: posts,
    error,
    isLoading,
    isFetching,
    refetch,
  } = useGetPostsQuery({ page, limit: 10 })
  
  const [createPost, { 
    isLoading: isCreating,
    error: createError 
  }] = useCreatePostMutation()
  
  const [updatePost] = useUpdatePostMutation()
  const [deletePost] = useDeletePostMutation()

  const handleCreatePost = async () => {
    if (!newPostTitle.trim()) return
    
    try {
      await createPost({
        title: newPostTitle,
        content: 'New post content',
        authorId: 'current-user-id'
      }).unwrap()
      
      setNewPostTitle('')
    } catch (error) {
      console.error('Failed to create post:', error)
    }
  }

  const handleUpdatePost = async (id: string, title: string) => {
    try {
      await updatePost({ id, title }).unwrap()
    } catch (error) {
      console.error('Failed to update post:', error)
    }
  }

  const handleDeletePost = async (id: string) => {
    if (window.confirm('Delete this post?')) {
      try {
        await deletePost(id).unwrap()
      } catch (error) {
        console.error('Failed to delete post:', error)
      }
    }
  }

  if (isLoading) return <div>Loading...</div>
  if (error) return <div>Error: {error.toString()}</div>

  return (
    <div>
      {/* Create new post */}
      <div>
        <input
          type="text"
          value={newPostTitle}
          onChange={(e) => setNewPostTitle(e.target.value)}
          placeholder="Enter post title"
        />
        <button onClick={handleCreatePost} disabled={isCreating}>
          {isCreating ? 'Creating...' : 'Create Post'}
        </button>
        {createError && <div>Error: {createError.toString()}</div>}
      </div>

      {/* Posts list */}
      <div>
        {isFetching && <div>Refreshing...</div>}
        
        {posts?.map((post) => (
          <div key={post.id}>
            <h3>{post.title}</h3>
            <p>{post.content}</p>
            <button onClick={() => handleUpdatePost(post.id, 'Updated: ' + post.title)}>
              Update
            </button>
            <button onClick={() => handleDeletePost(post.id)}>
              Delete
            </button>
          </div>
        ))}
      </div>

      {/* Pagination */}
      <div>
        <button onClick={() => setPage(p => Math.max(1, p - 1))} disabled={page === 1}>
          Previous
        </button>
        <span>Page {page}</span>
        <button onClick={() => setPage(p => p + 1)}>
          Next
        </button>
        <button onClick={refetch}>
          Refresh
        </button>
      </div>
    </div>
  )
}
```

### Step 7: Connect to React App

#### Setup Provider
```typescript
// src/index.tsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import { Provider } from 'react-redux'
import { store } from './store'
import App from './App'

const root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement)

root.render(
  <React.StrictMode>
    <Provider store={store}>
      <App />
    </Provider>
  </React.StrictMode>
)
```

#### Main App Component
```typescript
// src/App.tsx
import React from 'react'
import { useAppSelector } from './store/hooks'
import { selectIsAuthenticated } from './features/auth/authSlice'
import LoginForm from './components/LoginForm'
import PostsList from './components/PostsList'

const App: React.FC = () => {
  const isAuthenticated = useAppSelector(selectIsAuthenticated)

  return (
    <div className="App">
      <header>
        <h1>Redux Toolkit Demo</h1>
      </header>
      
      <main>
        {isAuthenticated ? (
          <PostsList />
        ) : (
          <LoginForm />
        )}
      </main>
    </div>
  )
}

export default App
```

This comprehensive step-by-step guide covers everything needed to set up Redux Toolkit from scratch, including store configuration, slice creation, async thunks, RTK Query setup, and component integration with proper TypeScript support.

## Redux Toolkit Fundamentals

### createSlice Flow Diagram
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        createSlice()                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Input: {name, initialState, reducers, extraReducers}          â”‚
â”‚                                â”‚                                â”‚
â”‚                                â–¼                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚                   Processing                            â”‚    â”‚
â”‚  â”‚                                                         â”‚    â”‚
â”‚  â”‚  â€¢ Generate action creators                             â”‚    â”‚
â”‚  â”‚  â€¢ Generate action types                                â”‚    â”‚
â”‚  â”‚  â€¢ Create reducer function                              â”‚    â”‚
â”‚  â”‚  â€¢ Add Immer for immutability                           â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                â”‚                                â”‚
â”‚                                â–¼                                â”‚
â”‚  Output: {actions, reducer, name, getInitialState}             â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Example Flow:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ counterSlice.   â”‚â”€â”€â”€â–ºâ”‚ Action Creator  â”‚â”€â”€â”€â–ºâ”‚ Reducer Updates â”‚
â”‚ actions.        â”‚    â”‚                 â”‚    â”‚                 â”‚
â”‚ increment()     â”‚    â”‚ {type:          â”‚    â”‚ state.value++   â”‚
â”‚                 â”‚    â”‚ 'counter/       â”‚    â”‚ (via Immer)     â”‚
â”‚                 â”‚    â”‚  increment'}    â”‚    â”‚                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### createAsyncThunk Flow
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    createAsyncThunk Lifecycle                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Component Dispatch
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    pending      â”‚ â”€â”€â–º { type: 'users/fetchUser/pending' }
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Async Function â”‚
â”‚   Execution     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â–¼
    Success? â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€ Yes â”€â”€â–º â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚          â”‚            â”‚    fulfilled    â”‚
        â”‚          â”‚            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚          â”‚
        â”‚          â””â”€â”€â”€ No â”€â”€â”€â–º â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                       â”‚    rejected     â”‚
        â”‚                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ State Updated   â”‚
â”‚ in extraReducersâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

State Transitions:
Loading: false â†’ true â†’ false
Error: null â†’ null/error message
Data: null â†’ null/data
```

### RTK Query Architecture
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      RTK Query Flow                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Component
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Generated Hook â”‚â”€â”€â”€â–ºâ”‚   Cache Check   â”‚â”€â”€â”€â–ºâ”‚  Server Call?   â”‚
â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚
â”‚ useGetUserQuery â”‚    â”‚ Is data fresh?  â”‚    â”‚ Yes â”‚    No     â”‚
â”‚    (userId)     â”‚    â”‚ Is it cached?   â”‚    â”‚  â”‚  â”‚     â”‚     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”¼â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”˜
                                                 â”‚  â”‚     â”‚
                                                 â–¼  â”‚     â–¼
                                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  Return
                                        â”‚ API Call    â”‚  Cached
                                        â”‚             â”‚  Data
                                        â”‚ baseQuery + â”‚
                                        â”‚ transform   â”‚
                                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                 â”‚
                                                 â–¼
                                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                        â”‚Update Cache â”‚
                                        â”‚& Normalize  â”‚
                                        â”‚             â”‚
                                        â”‚Invalidate   â”‚
                                        â”‚Tags if neededâ”‚
                                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Cache Structure:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Cache Slices                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  api: {                                                         â”‚
â”‚    queries: {                                                   â”‚
â”‚      'getUser(1)': {                                            â”‚
â”‚        status: 'fulfilled',                                     â”‚
â”‚        data: { id: 1, name: 'John' },                          â”‚
â”‚        requestId: 'abc123',                                     â”‚
â”‚        startedTimeStamp: 1627846261721                          â”‚
â”‚      }                                                          â”‚
â”‚    },                                                           â”‚
â”‚    mutations: {                                                 â”‚
â”‚      'updateUser(1)': { ... }                                  â”‚
â”‚    },                                                           â”‚
â”‚    provided: {                                                  â”‚
â”‚      User: {                                                    â”‚
â”‚        '1': ['getUser(1)', 'updateUser(1)']                    â”‚
â”‚      }                                                          â”‚
â”‚    }                                                            â”‚
â”‚  }                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Advanced RTK Query

### Custom Base Query with Authentication
```typescript
import { fetchBaseQuery } from '@reduxjs/toolkit/query/react'
import type { BaseQueryFn, FetchArgs, FetchBaseQueryError } from '@reduxjs/toolkit/query'

const baseQuery = fetchBaseQuery({
  baseUrl: '/api/',
  prepareHeaders: (headers, { getState }) => {
    const token = (getState() as RootState).auth.token
    if (token) {
      headers.set('authorization', `Bearer ${token}`)
    }
    return headers
  },
})

const baseQueryWithReauth: BaseQueryFn<
  string | FetchArgs,
  unknown,
  FetchBaseQueryError
> = async (args, api, extraOptions) => {
  let result = await baseQuery(args, api, extraOptions)
  
  if (result.error && result.error.status === 401) {
    // Try to get a new token
    const refreshResult = await baseQuery('/auth/refresh', api, extraOptions)
    
    if (refreshResult.data) {
      api.dispatch(tokenReceived(refreshResult.data))
      // Retry the initial query
      result = await baseQuery(args, api, extraOptions)
    } else {
      api.dispatch(loggedOut())
    }
  }
  return result
}
```

### Advanced Query Transformation
```typescript
export const advancedApi = createApi({
  reducerPath: 'advancedApi',
  baseQuery: baseQueryWithReauth,
  tagTypes: ['User', 'Post', 'Comment'],
  endpoints: (builder) => ({
    getPosts: builder.query<Post[], { page: number; filters: PostFilters }>({
      query: ({ page, filters }) => ({
        url: 'posts',
        params: { page, ...filters }
      }),
      transformResponse: (response: ApiResponse<Post[]>, meta, arg) => {
        // Complex data transformation
        return response.data.map(post => ({
          ...post,
          createdAt: new Date(post.createdAt),
          tags: post.tags.filter(tag => tag.active),
          author: {
            ...post.author,
            displayName: post.author.firstName + ' ' + post.author.lastName
          }
        }))
      },
      transformErrorResponse: (response: FetchBaseQueryError) => {
        return {
          status: response.status,
          message: typeof response.data === 'object' && response.data && 'message' in response.data
            ? response.data.message
            : 'An error occurred'
        }
      },
      providesTags: (result, error, arg) =>
        result
          ? [
              ...result.map(({ id }) => ({ type: 'Post' as const, id })),
              { type: 'Post', id: 'LIST' },
            ]
          : [{ type: 'Post', id: 'LIST' }],
    }),
    
    updatePost: builder.mutation<Post, Partial<Post> & Pick<Post, 'id'>>({
      query: ({ id, ...patch }) => ({
        url: `posts/${id}`,
        method: 'PATCH',
        body: patch,
      }),
      invalidatesTags: (result, error, arg) => [
        { type: 'Post', id: arg.id },
        { type: 'Post', id: 'LIST' },
      ],
      // Optimistic updates
      onQueryStarted: async ({ id, ...patch }, { dispatch, queryFulfilled }) => {
        const patchResult = dispatch(
          advancedApi.util.updateQueryData('getPosts', undefined, (draft) => {
            const post = draft.find(p => p.id === id)
            if (post) {
              Object.assign(post, patch)
            }
          })
        )
        
        try {
          await queryFulfilled
        } catch {
          patchResult.undo()
        }
      },
    }),
  }),
})
```

### Streaming Updates with RTK Query
```typescript
export const streamingApi = createApi({
  reducerPath: 'streamingApi',
  baseQuery: fetchBaseQuery({ baseUrl: '/api/' }),
  endpoints: (builder) => ({
    getStreamingData: builder.query<StreamData[], void>({
      query: () => 'stream/data',
      // Enable streaming updates
      async onCacheEntryAdded(
        arg,
        { updateCachedData, cacheDataLoaded, cacheEntryRemoved }
      ) {
        const ws = new WebSocket('ws://localhost:8080/stream')
        
        try {
          await cacheDataLoaded
          
          const listener = (event: MessageEvent) => {
            const data = JSON.parse(event.data)
            updateCachedData((draft) => {
              draft.push(data)
            })
          }
          
          ws.addEventListener('message', listener)
        } catch {
          // Handle connection errors
        }
        
        await cacheEntryRemoved
        ws.close()
      },
    }),
  }),
})
```

## Custom Middleware with RTK

### Advanced Logging Middleware
```typescript
import { Middleware, MiddlewareAPI } from '@reduxjs/toolkit'

const advancedLoggerMiddleware: Middleware = (storeAPI: MiddlewareAPI) => (next) => (action) => {
  const startTime = performance.now()
  const prevState = storeAPI.getState()
  
  console.group(`ðŸ”„ Action: ${action.type}`)
  console.log('ðŸ“¤ Dispatching:', action)
  console.log('ðŸ“Š Previous State:', prevState)
  
  const result = next(action)
  
  const nextState = storeAPI.getState()
  const endTime = performance.now()
  
  console.log('ðŸ“ˆ New State:', nextState)
  console.log(`â±ï¸ Time taken: ${(endTime - startTime).toFixed(2)}ms`)
  
  // Detect state mutations (in development)
  if (process.env.NODE_ENV === 'development') {
    const stateDiff = getStateDiff(prevState, nextState)
    if (Object.keys(stateDiff).length > 0) {
      console.log('ðŸ”„ State Changes:', stateDiff)
    }
  }
  
  console.groupEnd()
  return result
}
```

### Error Boundary Middleware
```typescript
const errorBoundaryMiddleware: Middleware = (storeAPI) => (next) => (action) => {
  try {
    return next(action)
  } catch (error) {
    console.error('ðŸ’¥ Error in reducer:', error)
    
    // Send error to monitoring service
    errorReportingService.captureException(error, {
      action,
      state: storeAPI.getState(),
      timestamp: new Date().toISOString()
    })
    
    // Dispatch error action
    storeAPI.dispatch(globalErrorOccurred({
      message: error.message,
      stack: error.stack,
      action: action.type
    }))
    
    return error
  }
}
```

### Persistence Middleware
```typescript
const persistenceMiddleware: Middleware = (storeAPI) => (next) => (action) => {
  const result = next(action)
  
  // Define which actions should trigger persistence
  const persistableActions = ['user/login', 'user/updateProfile', 'settings/update']
  
  if (persistableActions.some(type => action.type.startsWith(type))) {
    const state = storeAPI.getState()
    const persistedState = {
      user: state.user,
      settings: state.settings
    }
    
    // Debounced persistence to avoid excessive writes
    debouncedPersist(persistedState)
  }
  
  return result
}

const debouncedPersist = debounce((state: any) => {
  localStorage.setItem('redux-state', JSON.stringify(state))
}, 1000)
```

## Performance Optimization

### Memoized Selectors with Reselect
```typescript
import { createSelector, createSelectorCreator, lruMemoize } from 'reselect'

// Custom memoization for expensive computations
const createDeepEqualSelector = createSelectorCreator(
  lruMemoize,
  {
    maxSize: 50,
    equalityCheck: (a, b) => isEqual(a, b) // Using lodash isEqual
  }
)

// Complex selector with multiple dependencies
const selectUserPostsWithComments = createSelector(
  [
    (state: RootState) => state.users.entities,
    (state: RootState) => state.posts.entities,
    (state: RootState) => state.comments.entities,
    (state: RootState, userId: string) => userId
  ],
  (users, posts, comments, userId) => {
    const user = users[userId]
    if (!user) return []
    
    return user.postIds
      .map(postId => posts[postId])
      .filter(Boolean)
      .map(post => ({
        ...post,
        comments: post.commentIds
          .map(commentId => comments[commentId])
          .filter(Boolean)
          .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())
      }))
      .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())
  }
)

// Parametric selector factory
const makeSelectPostsByCategory = () => createSelector(
  [
    (state: RootState) => state.posts.entities,
    (state: RootState, category: string) => category
  ],
  (posts, category) => Object.values(posts).filter(post => post.category === category)
)
```

### Normalized State Structure
```typescript
// Using @reduxjs/toolkit's createEntityAdapter for normalized state
const postsAdapter = createEntityAdapter<Post>({
  selectId: (post) => post.id,
  sortComparer: (a, b) => b.createdAt.localeCompare(a.createdAt),
})

const postsSlice = createSlice({
  name: 'posts',
  initialState: postsAdapter.getInitialState({
    loading: false,
    error: null,
    selectedPostId: null,
    filters: {
      category: null,
      dateRange: null,
      author: null
    }
  }),
  reducers: {
    addPost: postsAdapter.addOne,
    addPosts: postsAdapter.addMany,
    updatePost: postsAdapter.updateOne,
    removePost: postsAdapter.removeOne,
    setSelectedPost: (state, action) => {
      state.selectedPostId = action.payload
    },
    setFilters: (state, action) => {
      state.filters = { ...state.filters, ...action.payload }
    }
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchPosts.pending, (state) => {
        state.loading = true
        state.error = null
      })
      .addCase(fetchPosts.fulfilled, (state, action) => {
        state.loading = false
        postsAdapter.setAll(state, action.payload)
      })
      .addCase(fetchPosts.rejected, (state, action) => {
        state.loading = false
        state.error = action.error.message || 'Failed to fetch posts'
      })
  },
})

// Export selectors
export const {
  selectAll: selectAllPosts,
  selectById: selectPostById,
  selectIds: selectPostIds,
  selectEntities: selectPostEntities,
  selectTotal: selectTotalPosts
} = postsAdapter.getSelectors((state: RootState) => state.posts)
```

## Advanced State Management Patterns

### State Machines with RTK
```typescript
// Finite state machine pattern for complex UI states
type LoadingState = 'idle' | 'loading' | 'succeeded' | 'failed'
type EditMode = 'view' | 'edit' | 'preview'

interface FormSliceState {
  loadingState: LoadingState
  editMode: EditMode
  data: FormData | null
  errors: Record<string, string>
  isDirty: boolean
  lastSaved: string | null
}

const formSlice = createSlice({
  name: 'form',
  initialState: {
    loadingState: 'idle' as LoadingState,
    editMode: 'view' as EditMode,
    data: null,
    errors: {},
    isDirty: false,
    lastSaved: null
  } as FormSliceState,
  reducers: {
    startEditing: (state) => {
      if (state.editMode === 'view') {
        state.editMode = 'edit'
      }
    },
    cancelEditing: (state) => {
      state.editMode = 'view'
      state.isDirty = false
      state.errors = {}
    },
    updateField: (state, action: PayloadAction<{ field: string; value: any }>) => {
      if (state.editMode === 'edit' && state.data) {
        state.data[action.payload.field] = action.payload.value
        state.isDirty = true
        // Clear field error when user starts typing
        delete state.errors[action.payload.field]
      }
    },
    setErrors: (state, action: PayloadAction<Record<string, string>>) => {
      state.errors = action.payload
    },
    transitionToPreview: (state) => {
      if (state.editMode === 'edit') {
        state.editMode = 'preview'
      }
    }
  },
  extraReducers: (builder) => {
    builder
      .addCase(saveForm.pending, (state) => {
        state.loadingState = 'loading'
      })
      .addCase(saveForm.fulfilled, (state) => {
        state.loadingState = 'succeeded'
        state.editMode = 'view'
        state.isDirty = false
        state.errors = {}
        state.lastSaved = new Date().toISOString()
      })
      .addCase(saveForm.rejected, (state, action) => {
        state.loadingState = 'failed'
        if (action.payload && typeof action.payload === 'object') {
          state.errors = action.payload as Record<string, string>
        }
      })
  }
})
```

### Saga-like Effects with RTK
```typescript
// Using createAsyncThunk for complex async flows
const processPayment = createAsyncThunk<
  PaymentResult,
  PaymentRequest,
  { rejectValue: PaymentError }
>(
  'payment/process',
  async (paymentRequest, { dispatch, getState, rejectWithValue }) => {
    try {
      // Step 1: Validate payment
      dispatch(setPaymentStatus('validating'))
      const validationResult = await validatePayment(paymentRequest)
      
      if (!validationResult.valid) {
        return rejectWithValue({
          code: 'VALIDATION_FAILED',
          message: validationResult.message
        })
      }
      
      // Step 2: Process payment
      dispatch(setPaymentStatus('processing'))
      const paymentResult = await processPaymentAPI(paymentRequest)
      
      // Step 3: Update user balance
      dispatch(updateUserBalance(paymentResult.amount))
      
      // Step 4: Send confirmation
      dispatch(sendPaymentConfirmation({
        userId: paymentRequest.userId,
        transactionId: paymentResult.transactionId
      }))
      
      dispatch(setPaymentStatus('completed'))
      return paymentResult
      
    } catch (error) {
      dispatch(setPaymentStatus('failed'))
      
      if (error.code === 'INSUFFICIENT_FUNDS') {
        return rejectWithValue({
          code: 'INSUFFICIENT_FUNDS',
          message: 'Insufficient funds in account'
        })
      }
      
      throw error
    }
  }
)
```

### Advanced Slice Composition
```typescript
// Higher-order slice factory for reusable patterns
function createAsyncSlice<T>(name: string, asyncThunk: any) {
  return createSlice({
    name,
    initialState: {
      data: null as T | null,
      loading: false,
      error: null as string | null,
      lastUpdated: null as string | null
    },
    reducers: {
      reset: (state) => {
        state.data = null
        state.loading = false
        state.error = null
        state.lastUpdated = null
      },
      updateData: (state, action: PayloadAction<Partial<T>>) => {
        if (state.data) {
          Object.assign(state.data, action.payload)
        }
      }
    },
    extraReducers: (builder) => {
      builder
        .addCase(asyncThunk.pending, (state) => {
          state.loading = true
          state.error = null
        })
        .addCase(asyncThunk.fulfilled, (state, action) => {
          state.loading = false
          state.data = action.payload
          state.lastUpdated = new Date().toISOString()
        })
        .addCase(asyncThunk.rejected, (state, action) => {
          state.loading = false
          state.error = action.error.message || 'An error occurred'
        })
    }
  })
}

// Usage
const userSlice = createAsyncSlice<User>('user', fetchUser)
const profileSlice = createAsyncSlice<Profile>('profile', fetchProfile)
```

## Testing Strategies

### Testing RTK Slices
```typescript
import { configureStore } from '@reduxjs/toolkit'
import { userSlice, UserState } from '../userSlice'

describe('userSlice', () => {
  let store: ReturnType<typeof configureStore>
  
  beforeEach(() => {
    store = configureStore({
      reducer: {
        user: userSlice.reducer
      }
    })
  })
  
  describe('reducers', () => {
    it('should handle login', () => {
      const loginData = { id: '1', name: 'John Doe', email: 'john@example.com' }
      
      store.dispatch(userSlice.actions.loginSuccess(loginData))
      
      const state = store.getState().user
      expect(state.isAuthenticated).toBe(true)
      expect(state.data).toEqual(loginData)
      expect(state.error).toBeNull()
    })
    
    it('should handle logout', () => {
      // First login
      store.dispatch(userSlice.actions.loginSuccess({ 
        id: '1', 
        name: 'John', 
        email: 'john@example.com' 
      }))
      
      // Then logout
      store.dispatch(userSlice.actions.logout())
      
      const state = store.getState().user
      expect(state.isAuthenticated).toBe(false)
      expect(state.data).toBeNull()
    })
  })
  
  describe('async thunks', () => {
    it('should handle successful login', async () => {
      const mockUser = { id: '1', name: 'John', email: 'john@example.com' }
      
      // Mock the API call
      jest.spyOn(api, 'login').mockResolvedValueOnce(mockUser)
      
      await store.dispatch(loginUser({ email: 'john@example.com', password: 'password' }))
      
      const state = store.getState().user
      expect(state.loading).toBe(false)
      expect(state.data).toEqual(mockUser)
      expect(state.error).toBeNull()
    })
  })
})
```

### Testing RTK Query
```typescript
import { setupApiStore } from '../testUtils'
import { api } from '../api'

describe('api', () => {
  const storeRef = setupApiStore(api)
  
  afterEach(() => {
    storeRef.store.dispatch(api.util.resetApiState())
  })
  
  describe('getPosts', () => {
    it('should return posts data', async () => {
      const mockPosts = [
        { id: '1', title: 'Post 1', content: 'Content 1' },
        { id: '2', title: 'Post 2', content: 'Content 2' }
      ]
      
      fetchMock.mockResponseOnce(JSON.stringify(mockPosts))
      
      const result = await storeRef.store.dispatch(
        api.endpoints.getPosts.initiate()
      )
      
      expect(result.data).toEqual(mockPosts)
      expect(result.isSuccess).toBe(true)
    })
    
    it('should handle error responses', async () => {
      fetchMock.mockRejectOnce(new Error('Network error'))
      
      const result = await storeRef.store.dispatch(
        api.endpoints.getPosts.initiate()
      )
      
      expect(result.isError).toBe(true)
      expect(result.error).toBeDefined()
    })
  })
})
```

### Integration Testing
```typescript
// Test utility for setting up store with all middleware
export function setupTestStore(preloadedState?: Partial<RootState>) {
  const store = configureStore({
    reducer: rootReducer,
    middleware: (getDefaultMiddleware) =>
      getDefaultMiddleware({
        serializableCheck: false, // Disable for testing
      }).concat(api.middleware),
    preloadedState
  })
  
  return { store }
}

describe('User Authentication Flow', () => {
  it('should handle complete login flow', async () => {
    const { store } = setupTestStore()
    
    // Mock API responses
    fetchMock.mockResponseOnce(JSON.stringify({
      user: { id: '1', name: 'John' },
      token: 'mock-token'
    }))
    
    // Dispatch login action
    const loginPromise = store.dispatch(
      loginUser({ email: 'john@example.com', password: 'password' })
    )
    
    // Check intermediate state
    expect(store.getState().auth.loading).toBe(true)
    
    // Wait for completion
    await loginPromise
    
    // Check final state
    const finalState = store.getState()
    expect(finalState.auth.loading).toBe(false)
    expect(finalState.auth.user).toBeDefined()
    expect(finalState.auth.token).toBe('mock-token')
  })
})
```

## TypeScript Integration

### Advanced Type Safety
```typescript
// Strongly typed state and actions
export interface RootState {
  auth: AuthState
  users: EntityState<User>
  posts: EntityState<Post>
  ui: UIState
}

// Type-safe action creators with payload validation
export const updateUserProfile = createAction(
  'user/updateProfile',
  (updates: Partial<User>) => {
    // Validate updates at runtime
    if (updates.email && !isValidEmail(updates.email)) {
      throw new Error('Invalid email format')
    }
    
    return {
      payload: updates,
      meta: {
        timestamp: Date.now()
      }
    }
  }
)

// Type-safe selectors with parameter validation
export const selectUserById = (state: RootState, userId: string): User | undefined => {
  return state.users.entities[userId]
}

// Typed hooks
export const useAppDispatch = () => useDispatch<AppDispatch>()
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector

// RTK Query with full TypeScript support
export const typedApi = createApi({
  reducerPath: 'typedApi',
  baseQuery: fetchBaseQuery({ baseUrl: '/api/' }),
  tagTypes: ['User', 'Post'] as const,
  endpoints: (builder) => ({
    getUser: builder.query<User, string>({
      query: (id) => `users/${id}`,
      providesTags: (result, error, id) => [{ type: 'User', id }]
    }),
    updateUser: builder.mutation<User, Partial<User> & Pick<User, 'id'>>({
      query: ({ id, ...patch }) => ({
        url: `users/${id}`,
        method: 'PATCH',
        body: patch
      }),
      invalidatesTags: (result, error, { id }) => [{ type: 'User', id }]
    })
  })
})

// Auto-generated typed hooks
export const {
  useGetUserQuery,
  useUpdateUserMutation
} = typedApi
```

### Custom Type Guards
```typescript
// Type guards for runtime type checking
function isUser(obj: any): obj is User {
  return obj && 
    typeof obj.id === 'string' &&
    typeof obj.name === 'string' &&
    typeof obj.email === 'string'
}

function isApiError(obj: any): obj is ApiError {
  return obj && 
    typeof obj.status === 'number' &&
    typeof obj.message === 'string'
}

// Using type guards in reducers
const userSlice = createSlice({
  name: 'user',
  initialState,
  reducers: {
    updateUser: (state, action) => {
      if (isUser(action.payload)) {
        state.data = action.payload
      } else {
        console.error('Invalid user data received')
      }
    }
  }
})
```

## Real-world Architecture

### Feature-based Structure
```
src/
  store/
    index.ts                 # Store configuration
    rootReducer.ts          # Root reducer
    middleware.ts           # Custom middleware
  features/
    auth/
      authSlice.ts
      authApi.ts
      authSelectors.ts
      authTypes.ts
      hooks/
        useAuth.ts
        useAuthGuard.ts
    posts/
      postsSlice.ts
      postsApi.ts
      postsSelectors.ts
      postsTypes.ts
      hooks/
        usePosts.ts
        usePostMutations.ts
  shared/
    api/
      baseApi.ts
      types.ts
    hooks/
      useAppDispatch.ts
      useAppSelector.ts
    utils/
      stateUtils.ts
      testUtils.ts
```

### Store Configuration
```typescript
// Advanced store setup with environment-specific middleware
export const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) => {
    const middleware = getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER],
        ignoredPaths: ['api.queries', 'api.mutations'],
      },
      immutableCheck: {
        ignoredPaths: ['api.queries', 'api.mutations'],
      },
    })
    
    // Add RTK Query middleware
    middleware.concat(api.middleware)
    
    // Environment-specific middleware
    if (process.env.NODE_ENV === 'development') {
      middleware.concat(
        advancedLoggerMiddleware,
        createStateSyncMiddleware({
          predicate: (action) => action.type.startsWith('sync/')
        })
      )
    }
    
    if (process.env.NODE_ENV === 'production') {
      middleware.concat(
        errorBoundaryMiddleware,
        analyticsMiddleware
      )
    }
    
    return middleware
  },
  devTools: process.env.NODE_ENV !== 'production' && {
    trace: true,
    traceLimit: 25,
    actionCreators: {
      ...authSlice.actions,
      ...postsSlice.actions,
    },
  },
})

// Enable hot reloading for reducers in development
if (process.env.NODE_ENV === 'development' && module.hot) {
  module.hot.accept('./rootReducer', () => {
    const newRootReducer = require('./rootReducer').default
    store.replaceReducer(newRootReducer)
  })
}
```

### Best Practices Summary

1. **Use RTK Query for server state** - Let RTK Query handle caching, synchronization, and background updates
2. **Normalize your state** - Use `createEntityAdapter` for collections
3. **Leverage TypeScript** - Get full type safety across your entire Redux setup
4. **Test thoroughly** - Unit test slices, integration test flows
5. **Optimize selectors** - Use `createSelector` for expensive computations
6. **Structure by features** - Keep related code together
7. **Handle errors gracefully** - Use error boundaries and proper error states
8. **Monitor performance** - Use Redux DevTools and custom middleware for insights
9. **Keep reducers pure** - All side effects should be in middleware or thunks
10. **Use immer patterns** - RTK uses Immer under the hood, write "mutative" logic

### Performance Monitoring
```typescript
// Custom performance monitoring middleware
const performanceMiddleware: Middleware = (store) => (next) => (action) => {
  const start = performance.now()
  const result = next(action)
  const end = performance.now()
  
  const duration = end - start
  
  if (duration > 16.67) { // Longer than one frame (60fps)
    console.warn(`Slow action detected: ${action.type} took ${duration.toFixed(2)}ms`)
    
    // Send to analytics in production
    if (process.env.NODE_ENV === 'production') {
      analytics.track('slow_redux_action', {
        actionType: action.type,
        duration,
        timestamp: Date.now()
      })
    }
  }
  
  return result
}
```

This guide covers advanced Redux Toolkit patterns that are essential for building scalable, maintainable applications. Each section builds upon the previous concepts and demonstrates real-world usage patterns.