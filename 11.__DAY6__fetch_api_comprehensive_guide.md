# Fetch API & Related Web APIs Comprehensive Guide

## Table of Contents
1. [Fetch API Basics](#fetch-api-basics)
2. [Request Configuration](#request-configuration)
3. [Response Handling](#response-handling)
4. [Headers Management](#headers-management)
   - [Working with Headers](#working-with-headers)
   - [Common Headers](#common-headers)
   - [Cache Headers in Detail](#cache-headers-in-detail)
   - [CORS Headers in Detail](#cors-headers-in-detail)
5. [Error Handling](#error-handling)
6. [Advanced Patterns](#advanced-patterns)
7. [Related Web APIs](#related-web-apis)
   - [URLSearchParams](#urlsearchparams)
   - [URL Constructor](#url-constructor)
   - [FormData](#formdata)
   - [File and Blob APIs](#file-and-blob-apis)
   - [Intersection Observer](#intersection-observer-for-lazy-loading)
   - [Server-Sent Events (SSE)](#server-sent-events-sse)
8. [Best Practices](#best-practices)
9. [Examples & Use Cases](#examples--use-cases)

---

## Fetch API Basics

The Fetch API provides a modern, promise-based interface for making HTTP requests in JavaScript, replacing the older XMLHttpRequest.

### Basic Syntax
```javascript
fetch(url, options)
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
```

### Simple GET Request
```javascript
// Basic GET request
fetch('https://api.example.com/users')
  .then(response => {
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return response.json();
  })
  .then(users => console.log(users));
```

### Using async/await
```javascript
async function fetchUsers() {
  try {
    const response = await fetch('https://api.example.com/users');
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const users = await response.json();
    return users;
  } catch (error) {
    console.error('Failed to fetch users:', error);
  }
}
```

---

## Request Configuration

The second parameter of fetch() accepts an options object to configure the request.

### HTTP Methods
```javascript
// GET (default)
fetch('/api/users');

// POST
fetch('/api/users', {
  method: 'POST',
  body: JSON.stringify({ name: 'John', email: 'john@example.com' }),
  headers: { 'Content-Type': 'application/json' }
});

// PUT
fetch('/api/users/1', {
  method: 'PUT',
  body: JSON.stringify({ name: 'John Updated' }),
  headers: { 'Content-Type': 'application/json' }
});

// DELETE
fetch('/api/users/1', { method: 'DELETE' });

// PATCH
fetch('/api/users/1', {
  method: 'PATCH',
  body: JSON.stringify({ email: 'newemail@example.com' }),
  headers: { 'Content-Type': 'application/json' }
});
```

### Request Body Types
```javascript
// JSON data
fetch('/api/data', {
  method: 'POST',
  body: JSON.stringify({ key: 'value' }),
  headers: { 'Content-Type': 'application/json' }
});

// Form data
const formData = new FormData();
formData.append('file', fileInput.files[0]);
formData.append('name', 'Document');
fetch('/api/upload', {
  method: 'POST',
  body: formData
});

// URL-encoded data
const params = new URLSearchParams();
params.append('username', 'john');
params.append('password', 'secret');
fetch('/api/login', {
  method: 'POST',
  body: params,
  headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
});

// Raw text
fetch('/api/text', {
  method: 'POST',
  body: 'Plain text content',
  headers: { 'Content-Type': 'text/plain' }
});

// Blob/ArrayBuffer
fetch('/api/binary', {
  method: 'POST',
  body: new Blob(['binary data'], { type: 'application/octet-stream' })
});
```

### Request Options
```javascript
const options = {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer token123',
    'X-Custom-Header': 'value'
  },
  body: JSON.stringify(data),
  mode: 'cors',           // cors, no-cors, same-origin
  credentials: 'include', // include, omit, same-origin
  cache: 'no-cache',      // default, no-cache, reload, force-cache, only-if-cached
  redirect: 'follow',     // follow, error, manual
  referrer: 'no-referrer',// no-referrer, client, or URL
  signal: abortController.signal // For request cancellation
};

fetch('/api/endpoint', options);
```

---

## Response Handling

The Response object provides various methods to extract data from the response.

### Response Properties
```javascript
fetch('/api/data')
  .then(response => {
    console.log('Status:', response.status);        // 200, 404, 500, etc.
    console.log('Status Text:', response.statusText); // OK, Not Found, etc.
    console.log('OK:', response.ok);                // true if 200-299
    console.log('Headers:', response.headers);      // Headers object
    console.log('URL:', response.url);              // Final URL after redirects
    console.log('Type:', response.type);            // basic, cors, error, opaque
    console.log('Redirected:', response.redirected); // true if redirected
    
    return response.json();
  });
```

### Response Body Methods
```javascript
// JSON data
fetch('/api/users').then(res => res.json());

// Text content
fetch('/api/text').then(res => res.text());

// Blob (binary data)
fetch('/api/image').then(res => res.blob());

// ArrayBuffer
fetch('/api/binary').then(res => res.arrayBuffer());

// FormData
fetch('/api/form').then(res => res.formData());

// Clone response (can only read body once)
fetch('/api/data').then(response => {
  const clone = response.clone();
  return Promise.all([
    response.json(),
    clone.text()
  ]);
});
```

### Stream Processing
```javascript
async function processStream() {
  const response = await fetch('/api/large-data');
  const reader = response.body.getReader();
  
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    
    // Process chunk
    console.log('Received chunk:', value);
  }
}
```

---

## Headers Management

Headers provide metadata about the request and response.

### Working with Headers
```javascript
// Creating headers
const headers = new Headers();
headers.append('Content-Type', 'application/json');
headers.append('Authorization', 'Bearer token123');

// Or use object literal
const headers2 = new Headers({
  'Content-Type': 'application/json',
  'Authorization': 'Bearer token123'
});

// Reading headers from response
fetch('/api/data')
  .then(response => {
    console.log('Content-Type:', response.headers.get('content-type'));
    console.log('Has Auth:', response.headers.has('authorization'));
    
    // Iterate all headers
    for (const [key, value] of response.headers) {
      console.log(`${key}: ${value}`);
    }
  });
```

### Common Headers
```javascript
const commonHeaders = {
  // Content type
  'Content-Type': 'application/json',
  'Content-Type': 'application/x-www-form-urlencoded',
  'Content-Type': 'multipart/form-data',
  'Content-Type': 'text/plain',
  
  // Authentication
  'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIs...',
  'Authorization': 'Basic dXNlcjpwYXNz',
  'X-API-Key': 'your-api-key',
  
  // CORS and security
  'Access-Control-Allow-Origin': '*',
  'X-Requested-With': 'XMLHttpRequest',
  'X-CSRF-Token': 'csrf-token-value',
  
  // Caching
  'Cache-Control': 'no-cache',
  'If-None-Match': 'etag-value',
  
  // Custom headers
  'X-Client-Version': '1.0.0',
  'X-Request-ID': 'unique-id-123'
};
```

### Cache Headers in Detail

Caching headers control how responses are cached by browsers, proxies, and CDNs, significantly improving performance and reducing server load.

#### Request Cache Headers
```javascript
// Client cache control headers
const cacheHeaders = {
  // Force fresh request (bypass all caches)
  'Cache-Control': 'no-cache',
  
  // Don't store response in any cache
  'Cache-Control': 'no-store',
  
  // Use cached version only if less than 300 seconds old
  'Cache-Control': 'max-age=300',
  
  // Revalidate stale cache with server
  'Cache-Control': 'must-revalidate',
  
  // Only use cache, don't contact server
  'Cache-Control': 'only-if-cached',
  
  // Multiple directives
  'Cache-Control': 'no-cache, must-revalidate, max-age=0'
};

// Conditional requests (check if content changed)
fetch('/api/data', {
  headers: {
    'If-None-Match': '"etag-value-123"',        // ETag-based validation
    'If-Modified-Since': 'Wed, 21 Oct 2015 07:28:00 GMT' // Date-based validation
  }
});
```

#### Response Cache Headers (Server-side examples)
```javascript
// Examples of what server might return
const responseCacheHeaders = {
  // Cache for 1 hour (3600 seconds)
  'Cache-Control': 'max-age=3600',
  
  // Cache for 1 hour, but revalidate if stale
  'Cache-Control': 'max-age=3600, must-revalidate',
  
  // Private cache (browser only, not shared caches)
  'Cache-Control': 'private, max-age=3600',
  
  // Public cache (can be cached by CDNs, proxies)
  'Cache-Control': 'public, max-age=86400',
  
  // No caching at all
  'Cache-Control': 'no-store',
  
  // Cache but always revalidate
  'Cache-Control': 'no-cache',
  
  // ETag for content validation
  'ETag': '"abc123def456"',
  
  // Last modification date
  'Last-Modified': 'Wed, 21 Oct 2015 07:28:00 GMT',
  
  // When the response expires
  'Expires': 'Thu, 01 Dec 2024 16:00:00 GMT'
};
```

#### Practical Cache Control Examples
```javascript
// Cache-aware fetch wrapper
async function fetchWithCache(url, options = {}) {
  const cacheKey = `cache_${url}`;
  const cached = localStorage.getItem(cacheKey);
  
  if (cached) {
    const { data, timestamp, maxAge } = JSON.parse(cached);
    const age = Date.now() - timestamp;
    
    if (age < maxAge) {
      console.log('Using cached data');
      return { data, fromCache: true };
    }
  }
  
  try {
    const response = await fetch(url, {
      ...options,
      headers: {
        'Cache-Control': 'max-age=300', // 5 minutes
        ...options.headers
      }
    });
    
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    
    const data = await response.json();
    
    // Extract cache control from response
    const cacheControl = response.headers.get('cache-control');
    const maxAgeMatch = cacheControl?.match(/max-age=(\d+)/);
    const maxAge = maxAgeMatch ? parseInt(maxAgeMatch[1]) * 1000 : 300000; // Default 5 min
    
    // Store in cache
    localStorage.setItem(cacheKey, JSON.stringify({
      data,
      timestamp: Date.now(),
      maxAge
    }));
    
    return { data, fromCache: false };
  } catch (error) {
    // Fallback to stale cache on error
    if (cached) {
      const { data } = JSON.parse(cached);
      console.log('Using stale cache due to fetch error');
      return { data, fromCache: true, stale: true };
    }
    throw error;
  }
}

// ETags for conditional requests
class ETagCache {
  constructor() {
    this.cache = new Map();
  }
  
  async fetch(url, options = {}) {
    const cacheEntry = this.cache.get(url);
    const headers = { ...options.headers };
    
    if (cacheEntry?.etag) {
      headers['If-None-Match'] = cacheEntry.etag;
    }
    
    const response = await fetch(url, { ...options, headers });
    
    if (response.status === 304) {
      // Not modified, use cached data
      console.log('Using cached data (304 Not Modified)');
      return {
        data: cacheEntry.data,
        status: 200,
        fromCache: true
      };
    }
    
    if (response.ok) {
      const data = await response.json();
      const etag = response.headers.get('etag');
      
      if (etag) {
        this.cache.set(url, { data, etag });
      }
      
      return { data, status: response.status, fromCache: false };
    }
    
    throw new Error(`HTTP ${response.status}`);
  }
}

// Usage
const etagCache = new ETagCache();
const result = await etagCache.fetch('/api/data');
```

### CORS Headers in Detail

Cross-Origin Resource Sharing (CORS) headers control how resources can be accessed across different origins (domains, protocols, or ports).

#### Understanding CORS Concepts
```javascript
// Same origin (allowed by default)
const sameOrigin = {
  current: 'https://example.com/page',
  request: 'https://example.com/api/data' // ✅ Same origin
};

// Cross origin (requires CORS)
const crossOrigin = {
  current: 'https://app.example.com',
  request: 'https://api.different.com/data' // ❌ Different origin
};

// CORS preflight is triggered by:
// - Non-simple methods (PUT, DELETE, PATCH, etc.)
// - Custom headers
// - Content-Type other than application/x-www-form-urlencoded, multipart/form-data, text/plain
```

#### Client-side CORS Configuration
```javascript
// Simple CORS request (no preflight)
fetch('https://api.example.com/data', {
  method: 'GET',
  mode: 'cors', // Default for cross-origin requests
  credentials: 'omit' // Don't send cookies
});

// Complex CORS request (triggers preflight)
fetch('https://api.example.com/data', {
  method: 'PUT',
  mode: 'cors',
  credentials: 'include', // Send cookies with request
  headers: {
    'Content-Type': 'application/json',
    'X-Custom-Header': 'value',
    'Authorization': 'Bearer token123'
  },
  body: JSON.stringify({ key: 'value' })
});

// CORS mode options
const corsOptions = {
  mode: 'cors',        // Default - follows CORS protocol
  mode: 'no-cors',     // Limited request, opaque response
  mode: 'same-origin', // Only same-origin requests allowed
  mode: 'navigate'     // For navigation requests
};

// Credentials options
const credentialOptions = {
  credentials: 'omit',       // Never send cookies/auth
  credentials: 'same-origin', // Send cookies for same-origin only
  credentials: 'include'      // Always send cookies/auth
};
```

#### Server Response CORS Headers (Examples)
```javascript
// Basic CORS headers that server should return
const corsResponseHeaders = {
  // Allow specific origin
  'Access-Control-Allow-Origin': 'https://app.example.com',
  
  // Allow all origins (not recommended for production)
  'Access-Control-Allow-Origin': '*',
  
  // Allow credentials (cookies, authorization headers)
  'Access-Control-Allow-Credentials': 'true',
  
  // Allowed HTTP methods
  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
  
  // Allowed request headers
  'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Requested-With',
  
  // Headers that client can access
  'Access-Control-Expose-Headers': 'X-Total-Count, X-Page-Number',
  
  // How long to cache preflight response (seconds)
  'Access-Control-Max-Age': '86400' // 24 hours
};

// Example server setup (Express.js)
// app.use((req, res, next) => {
//   res.header('Access-Control-Allow-Origin', 'https://app.example.com');
//   res.header('Access-Control-Allow-Credentials', 'true');
//   res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE,OPTIONS');
//   res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
//   
//   if (req.method === 'OPTIONS') {
//     res.sendStatus(200);
//   } else {
//     next();
//   }
// });
```

#### CORS Error Handling
```javascript
async function corsAwareFetch(url, options = {}) {
  try {
    const response = await fetch(url, {
      mode: 'cors',
      ...options
    });
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    return response;
  } catch (error) {
    if (error.name === 'TypeError' && error.message.includes('CORS')) {
      console.error('CORS Error: The server did not include the correct CORS headers');
      throw new Error('Cross-origin request failed. Please check CORS configuration.');
    }
    
    if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {
      console.error('Network Error: Could be CORS, network, or server issue');
      throw new Error('Request failed. Check network connection and CORS settings.');
    }
    
    throw error;
  }
}

// CORS-safe request wrapper
class CORSClient {
  constructor(baseURL, allowedOrigins = []) {
    this.baseURL = baseURL;
    this.allowedOrigins = allowedOrigins;
  }
  
  isAllowedOrigin(url) {
    try {
      const urlObj = new URL(url);
      const currentOrigin = window.location.origin;
      const targetOrigin = urlObj.origin;
      
      if (currentOrigin === targetOrigin) return true;
      return this.allowedOrigins.includes(targetOrigin);
    } catch {
      return false;
    }
  }
  
  async request(endpoint, options = {}) {
    const url = new URL(endpoint, this.baseURL);
    
    if (!this.isAllowedOrigin(url.href)) {
      throw new Error(`Origin ${url.origin} is not in allowed list`);
    }
    
    const config = {
      mode: 'cors',
      credentials: 'include',
      headers: {
        'Content-Type': 'application/json',
        ...options.headers
      },
      ...options
    };
    
    try {
      const response = await fetch(url, config);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      return response;
    } catch (error) {
      if (error.message.includes('CORS') || error.message.includes('Failed to fetch')) {
        console.error(`CORS error for ${url}:`, error);
        throw new Error(`Cross-origin request to ${url.origin} failed. Check CORS settings.`);
      }
      throw error;
    }
  }
}

// Usage
const corsClient = new CORSClient('https://api.example.com', [
  'https://api.example.com',
  'https://cdn.example.com'
]);
```

#### CORS Preflight Handling
```javascript
// Understanding preflight requests
const preflightTriggers = {
  // These trigger preflight:
  complexMethods: ['PUT', 'DELETE', 'PATCH', 'POST'],
  customHeaders: ['Authorization', 'X-API-Key', 'X-Requested-With'],
  contentTypes: ['application/json', 'application/xml'],
  
  // These don't trigger preflight (simple requests):
  simpleMethods: ['GET', 'POST', 'HEAD'],
  simpleHeaders: ['Accept', 'Accept-Language', 'Content-Language'],
  simpleContentTypes: [
    'application/x-www-form-urlencoded',
    'multipart/form-data',
    'text/plain'
  ]
};

// Minimizing preflight requests
async function efficientCORS() {
  // ❌ Triggers preflight (JSON content-type)
  const complexRequest = fetch('https://api.example.com/data', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ key: 'value' })
  });
  
  // ✅ No preflight (simple content-type)
  const formData = new FormData();
  formData.append('key', 'value');
  const simpleRequest = fetch('https://api.example.com/data', {
    method: 'POST',
    body: formData
  });
  
  // ✅ No preflight (URL-encoded)
  const params = new URLSearchParams();
  params.append('key', 'value');
  const urlEncodedRequest = fetch('https://api.example.com/data', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: params
  });
}

// Handling preflight errors
function handlePreflightError(error) {
  console.error('Preflight request failed:', error);
  
  const suggestions = [
    'Check if the server handles OPTIONS requests',
    'Verify Access-Control-Allow-Methods includes your HTTP method',
    'Verify Access-Control-Allow-Headers includes your custom headers',
    'Check if Access-Control-Allow-Origin is set correctly',
    'Ensure Access-Control-Allow-Credentials is true if sending cookies'
  ];
  
  console.log('CORS troubleshooting suggestions:', suggestions);
}
```

#### Advanced CORS Patterns
```javascript
// Dynamic CORS origin handling
class DynamicCORSClient {
  constructor() {
    this.trustedDomains = [
      'example.com',
      'api.example.com',
      'cdn.example.com'
    ];
  }
  
  isTrustedDomain(url) {
    try {
      const hostname = new URL(url).hostname;
      return this.trustedDomains.some(domain => 
        hostname === domain || hostname.endsWith(`.${domain}`)
      );
    } catch {
      return false;
    }
  }
  
  async secureFetch(url, options = {}) {
    if (!this.isTrustedDomain(url)) {
      throw new Error(`Untrusted domain: ${new URL(url).hostname}`);
    }
    
    return fetch(url, {
      mode: 'cors',
      credentials: 'include',
      ...options
    });
  }
}

// CORS with retry logic
async function corsRetryFetch(url, options = {}, maxRetries = 3) {
  for (let i = 0; i <= maxRetries; i++) {
    try {
      return await fetch(url, {
        mode: 'cors',
        ...options
      });
    } catch (error) {
      if (i === maxRetries) throw error;
      
      if (error.message.includes('CORS')) {
        // Try with different CORS settings
        const fallbackOptions = {
          ...options,
          mode: 'no-cors',
          credentials: 'omit'
        };
        
        console.log(`CORS retry ${i + 1} with fallback options`);
        return fetch(url, fallbackOptions);
      }
      
      // Wait before retry
      await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
    }
  }
}

// CORS proxy for development
const corsProxy = {
  // Development proxy URLs
  proxies: [
    'https://cors-anywhere.herokuapp.com/',
    'https://api.allorigins.win/raw?url=',
    'https://thingproxy.freeboard.io/fetch/'
  ],
  
  async fetchWithProxy(url, options = {}) {
    const errors = [];
    
    // Try direct request first
    try {
      return await fetch(url, { mode: 'cors', ...options });
    } catch (error) {
      errors.push({ method: 'direct', error: error.message });
    }
    
    // Try with proxies
    for (const proxy of this.proxies) {
      try {
        const proxyUrl = proxy + encodeURIComponent(url);
        return await fetch(proxyUrl, { mode: 'cors', ...options });
      } catch (error) {
        errors.push({ method: `proxy: ${proxy}`, error: error.message });
      }
    }
    
    throw new Error(`All CORS methods failed: ${JSON.stringify(errors)}`);
  }
};

// Usage example
// Note: Use CORS proxies only in development!
if (process.env.NODE_ENV === 'development') {
  corsProxy.fetchWithProxy('https://api.external.com/data')
    .then(response => response.json())
    .then(data => console.log(data));
}
```
---

## Error Handling

Proper error handling is crucial for robust applications.

### Network vs HTTP Errors
```javascript
async function fetchWithErrorHandling(url) {
  try {
    const response = await fetch(url);
    
    // fetch() only rejects on network errors
    // HTTP errors (4xx, 5xx) are still "successful" responses
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    return await response.json();
  } catch (error) {
    if (error.name === 'TypeError') {
      // Network error (no internet, CORS, etc.)
      console.error('Network error:', error.message);
    } else {
      // HTTP error or JSON parsing error
      console.error('Request failed:', error.message);
    }
    throw error;
  }
}
```

### Detailed Error Handling
```javascript
class FetchError extends Error {
  constructor(response, message) {
    super(message);
    this.name = 'FetchError';
    this.response = response;
    this.status = response.status;
  }
}

async function safeFetch(url, options) {
  try {
    const response = await fetch(url, options);
    
    if (!response.ok) {
      let errorMessage = `HTTP ${response.status}`;
      
      // Try to get error details from response
      try {
        const errorData = await response.clone().json();
        errorMessage = errorData.message || errorMessage;
      } catch {
        // If JSON parsing fails, use status text
        errorMessage = response.statusText || errorMessage;
      }
      
      throw new FetchError(response, errorMessage);
    }
    
    return response;
  } catch (error) {
    if (error instanceof FetchError) {
      throw error;
    }
    
    // Network or other errors
    throw new Error(`Network error: ${error.message}`);
  }
}
```

### Status Code Handling
```javascript
async function handleResponse(response) {
  const data = await response.json();
  
  switch (response.status) {
    case 200:
      return data;
    case 201:
      console.log('Resource created successfully');
      return data;
    case 400:
      throw new Error(`Bad Request: ${data.message}`);
    case 401:
      throw new Error('Unauthorized - please log in');
    case 403:
      throw new Error('Forbidden - insufficient permissions');
    case 404:
      throw new Error('Resource not found');
    case 429:
      throw new Error('Too many requests - please try again later');
    case 500:
      throw new Error('Server error - please try again');
    default:
      throw new Error(`Unexpected status: ${response.status}`);
  }
}
```

---

## Advanced Patterns

### Request Cancellation with AbortController
```javascript
const controller = new AbortController();
const signal = controller.signal;

// Cancel after 5 seconds
setTimeout(() => controller.abort(), 5000);

fetch('/api/data', { signal })
  .then(response => response.json())
  .catch(error => {
    if (error.name === 'AbortError') {
      console.log('Request was cancelled');
    } else {
      console.error('Request failed:', error);
    }
  });

// Cancel immediately
controller.abort();
```

### Timeout Implementation
```javascript
function fetchWithTimeout(url, options = {}, timeout = 5000) {
  const controller = new AbortController();
  const signal = controller.signal;
  
  const timeoutId = setTimeout(() => controller.abort(), timeout);
  
  return fetch(url, { ...options, signal })
    .finally(() => clearTimeout(timeoutId));
}

// Usage
fetchWithTimeout('/api/slow-endpoint', {}, 3000)
  .then(response => response.json())
  .catch(error => {
    if (error.name === 'AbortError') {
      console.error('Request timed out');
    }
  });
```

### Retry Logic
```javascript
async function fetchWithRetry(url, options = {}, maxRetries = 3, delay = 1000) {
  let lastError;
  
  for (let i = 0; i <= maxRetries; i++) {
    try {
      const response = await fetch(url, options);
      if (response.ok) return response;
      throw new Error(`HTTP ${response.status}`);
    } catch (error) {
      lastError = error;
      
      if (i === maxRetries) break;
      
      console.log(`Retry ${i + 1}/${maxRetries} after ${delay}ms`);
      await new Promise(resolve => setTimeout(resolve, delay));
      delay *= 2; // Exponential backoff
    }
  }
  
  throw lastError;
}
```

### Request Queue/Rate Limiting
```javascript
class RequestQueue {
  constructor(maxConcurrent = 3, delayMs = 100) {
    this.maxConcurrent = maxConcurrent;
    this.delayMs = delayMs;
    this.running = 0;
    this.queue = [];
  }
  
  async add(url, options) {
    return new Promise((resolve, reject) => {
      this.queue.push({ url, options, resolve, reject });
      this.process();
    });
  }
  
  async process() {
    if (this.running >= this.maxConcurrent || this.queue.length === 0) {
      return;
    }
    
    this.running++;
    const { url, options, resolve, reject } = this.queue.shift();
    
    try {
      const response = await fetch(url, options);
      resolve(response);
    } catch (error) {
      reject(error);
    } finally {
      this.running--;
      setTimeout(() => this.process(), this.delayMs);
    }
  }
}

// Usage
const queue = new RequestQueue(2, 500);
queue.add('/api/data1').then(res => res.json());
queue.add('/api/data2').then(res => res.json());
```

### Progress Tracking
```javascript
async function fetchWithProgress(url, onProgress) {
  const response = await fetch(url);
  const contentLength = response.headers.get('content-length');
  const total = parseInt(contentLength, 10);
  let loaded = 0;
  
  const reader = response.body.getReader();
  const chunks = [];
  
  while (true) {
    const { done, value } = await reader.read();
    
    if (done) break;
    
    chunks.push(value);
    loaded += value.length;
    
    if (onProgress && total) {
      onProgress({ loaded, total, percentage: (loaded / total) * 100 });
    }
  }
  
  const allChunks = new Uint8Array(loaded);
  let position = 0;
  for (const chunk of chunks) {
    allChunks.set(chunk, position);
    position += chunk.length;
  }
  
  return new Response(allChunks, {
    status: response.status,
    statusText: response.statusText,
    headers: response.headers
  });
}

// Usage
fetchWithProgress('/api/large-file', (progress) => {
  console.log(`Downloaded: ${progress.percentage.toFixed(2)}%`);
}).then(response => response.blob());
```

---

## Related Web APIs

### URLSearchParams
```javascript
// Creating query strings
const params = new URLSearchParams();
params.append('q', 'javascript');
params.append('limit', '10');
params.append('sort', 'date');

console.log(params.toString()); // q=javascript&limit=10&sort=date

// From object
const params2 = new URLSearchParams({
  q: 'javascript',
  limit: 10,
  sort: 'date'
});

// Using with fetch
const queryString = new URLSearchParams({ search: 'term', page: 1 });
fetch(`/api/search?${queryString}`);

// Reading from current URL
const urlParams = new URLSearchParams(window.location.search);
const searchTerm = urlParams.get('q');
```

### URL Constructor
```javascript
// Creating URLs
const apiUrl = new URL('/api/users', 'https://example.com');
console.log(apiUrl.href); // https://example.com/api/users

// Adding search parameters
apiUrl.searchParams.set('limit', '20');
apiUrl.searchParams.set('page', '1');
console.log(apiUrl.href); // https://example.com/api/users?limit=20&page=1

// Parsing existing URLs
const url = new URL('https://api.example.com/users?page=1&limit=10');
console.log(url.pathname); // /users
console.log(url.searchParams.get('page')); // 1
```

### FormData
```javascript
// Creating form data
const formData = new FormData();
formData.append('name', 'John Doe');
formData.append('email', 'john@example.com');
formData.append('file', fileInput.files[0]);

// From HTML form
const form = document.getElementById('myForm');
const formData2 = new FormData(form);

// Iterate form data
for (const [key, value] of formData) {
  console.log(`${key}: ${value}`);
}

// Using with fetch
fetch('/api/submit', {
  method: 'POST',
  body: formData
});
```

### File and Blob APIs
```javascript
// Reading files
const fileInput = document.getElementById('file');
fileInput.addEventListener('change', async (event) => {
  const file = event.target.files[0];
  
  // File properties
  console.log('Name:', file.name);
  console.log('Size:', file.size);
  console.log('Type:', file.type);
  console.log('Last Modified:', file.lastModified);
  
  // Read as text
  const text = await file.text();
  
  // Read as array buffer
  const buffer = await file.arrayBuffer();
  
  // Read as data URL
  const reader = new FileReader();
  reader.onload = e => console.log(e.target.result);
  reader.readAsDataURL(file);
});

// Creating blobs
const blob = new Blob(['Hello, world!'], { type: 'text/plain' });
const jsonBlob = new Blob([JSON.stringify({ key: 'value' })], { 
  type: 'application/json' 
});

// Upload blob
fetch('/api/upload', {
  method: 'POST',
  body: blob
});
```

### Intersection Observer (for lazy loading)
```javascript
// Lazy load images with fetch
const imageObserver = new IntersectionObserver((entries) => {
  entries.forEach(async (entry) => {
    if (entry.isIntersecting) {
      const img = entry.target;
      const src = img.dataset.src;
      
      try {
        const response = await fetch(src);
        const blob = await response.blob();
        const objectURL = URL.createObjectURL(blob);
        
        img.src = objectURL;
        img.onload = () => URL.revokeObjectURL(objectURL);
        
        imageObserver.unobserve(img);
      } catch (error) {
        console.error('Failed to load image:', error);
      }
    }
  });
});

// Observe all lazy images
document.querySelectorAll('img[data-src]').forEach(img => {
  imageObserver.observe(img);
});
```

### Server-Sent Events (SSE)

Server-Sent Events provide a way to receive real-time updates from a server over a single HTTP connection. Unlike WebSockets, SSE is unidirectional (server to client only) and automatically handles reconnection.

#### Basic SSE Implementation
```javascript
// Basic EventSource usage
const eventSource = new EventSource('/api/stream');

eventSource.onopen = function(event) {
  console.log('SSE connection opened');
};

eventSource.onmessage = function(event) {
  console.log('Received data:', event.data);
  
  // Parse JSON data if needed
  try {
    const data = JSON.parse(event.data);
    updateUI(data);
  } catch (error) {
    console.log('Received plain text:', event.data);
  }
};

eventSource.onerror = function(event) {
  console.error('SSE error:', event);
  
  if (eventSource.readyState === EventSource.CLOSED) {
    console.log('SSE connection closed');
  }
};

// Close connection when done
// eventSource.close();
```

#### Custom Event Types
```javascript
// Server can send custom event types
const eventSource = new EventSource('/api/live-updates');

// Listen for default 'message' events
eventSource.onmessage = function(event) {
  console.log('Default message:', event.data);
};

// Listen for custom event types
eventSource.addEventListener('user-joined', function(event) {
  const user = JSON.parse(event.data);
  console.log('User joined:', user.name);
  addUserToList(user);
});

eventSource.addEventListener('chat-message', function(event) {
  const message = JSON.parse(event.data);
  console.log('New message:', message);
  displayMessage(message);
});

eventSource.addEventListener('system-alert', function(event) {
  const alert = JSON.parse(event.data);
  console.log('System alert:', alert);
  showNotification(alert.message, alert.type);
});
```

#### SSE with Authentication
```javascript
// SSE with authentication headers (limited support)
class AuthenticatedSSE {
  constructor(url, token) {
    this.url = url;
    this.token = token;
    this.eventSource = null;
    this.listeners = new Map();
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 5;
  }
  
  connect() {
    // EventSource doesn't support custom headers directly
    // Use token in URL or implement custom fetch-based SSE
    const urlWithAuth = new URL(this.url);
    urlWithAuth.searchParams.set('token', this.token);
    
    this.eventSource = new EventSource(urlWithAuth.toString());
    
    this.eventSource.onopen = () => {
      console.log('Authenticated SSE connection opened');
      this.reconnectAttempts = 0;
    };
    
    this.eventSource.onmessage = (event) => {
      this.handleMessage('message', event);
    };
    
    this.eventSource.onerror = (event) => {
      console.error('SSE error:', event);
      this.handleReconnect();
    };
    
    // Restore custom event listeners
    this.listeners.forEach((handler, eventType) => {
      this.eventSource.addEventListener(eventType, handler);
    });
  }
  
  addEventListener(eventType, handler) {
    this.listeners.set(eventType, handler);
    if (this.eventSource) {
      this.eventSource.addEventListener(eventType, handler);
    }
  }
  
  handleMessage(eventType, event) {
    try {
      const data = JSON.parse(event.data);
      console.log(`SSE ${eventType}:`, data);
    } catch (error) {
      console.log(`SSE ${eventType} (text):`, event.data);
    }
  }
  
  handleReconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      const delay = Math.pow(2, this.reconnectAttempts) * 1000; // Exponential backoff
      
      console.log(`Reconnecting SSE in ${delay}ms (attempt ${this.reconnectAttempts})`);
      
      setTimeout(() => {
        this.close();
        this.connect();
      }, delay);
    } else {
      console.error('Max SSE reconnection attempts reached');
    }
  }
  
  close() {
    if (this.eventSource) {
      this.eventSource.close();
      this.eventSource = null;
    }
  }
}

// Usage
const sseClient = new AuthenticatedSSE('/api/stream', 'your-jwt-token');
sseClient.addEventListener('notification', (event) => {
  const notification = JSON.parse(event.data);
  showNotification(notification.message);
});
sseClient.connect();
```

#### Fetch-based SSE Implementation
```javascript
// Custom SSE implementation using fetch for more control
class FetchSSE {
  constructor(url, options = {}) {
    this.url = url;
    this.options = {
      headers: {},
      ...options
    };
    this.controller = null;
    this.reader = null;
    this.listeners = new Map();
    this.isConnected = false;
  }
  
  async connect() {
    this.controller = new AbortController();
    
    try {
      const response = await fetch(this.url, {
        headers: {
          'Accept': 'text/event-stream',
          'Cache-Control': 'no-cache',
          ...this.options.headers
        },
        signal: this.controller.signal
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      
      this.isConnected = true;
      this.reader = response.body.getReader();
      this.processStream();
      
    } catch (error) {
      console.error('Fetch SSE connection failed:', error);
      this.handleError(error);
    }
  }
  
  async processStream() {
    const decoder = new TextDecoder();
    let buffer = '';
    
    try {
      while (this.isConnected) {
        const { done, value } = await this.reader.read();
        
        if (done) break;
        
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop() || ''; // Keep incomplete line in buffer
        
        let eventData = {
          type: 'message',
          data: '',
          id: null,
          retry: null
        };
        
        for (const line of lines) {
          if (line.trim() === '') {
            // Empty line indicates end of event
            if (eventData.data) {
              this.dispatchEvent(eventData);
              eventData = { type: 'message', data: '', id: null, retry: null };
            }
          } else if (line.startsWith('data:')) {
            eventData.data += line.slice(5).trim() + '\n';
          } else if (line.startsWith('event:')) {
            eventData.type = line.slice(6).trim();
          } else if (line.startsWith('id:')) {
            eventData.id = line.slice(3).trim();
          } else if (line.startsWith('retry:')) {
            eventData.retry = parseInt(line.slice(6).trim());
          }
        }
      }
    } catch (error) {
      if (error.name !== 'AbortError') {
        console.error('Stream processing error:', error);
        this.handleError(error);
      }
    }
  }
  
  dispatchEvent(eventData) {
    const event = {
      type: eventData.type,
      data: eventData.data.replace(/\n$/, ''), // Remove trailing newline
      lastEventId: eventData.id,
      origin: new URL(this.url).origin
    };
    
    const handler = this.listeners.get(eventData.type) || this.listeners.get('message');
    if (handler) {
      handler(event);
    }
  }
  
  addEventListener(eventType, handler) {
    this.listeners.set(eventType, handler);
  }
  
  removeEventListener(eventType) {
    this.listeners.delete(eventType);
  }
  
  handleError(error) {
    const errorHandler = this.listeners.get('error');
    if (errorHandler) {
      errorHandler({ error });
    }
  }
  
  close() {
    this.isConnected = false;
    if (this.controller) {
      this.controller.abort();
    }
    if (this.reader) {
      this.reader.releaseLock();
    }
  }
}

// Usage with custom headers
const fetchSSE = new FetchSSE('/api/stream', {
  headers: {
    'Authorization': 'Bearer your-jwt-token',
    'X-Client-ID': 'client-123'
  }
});

fetchSSE.addEventListener('message', (event) => {
  console.log('Message:', event.data);
});

fetchSSE.addEventListener('notification', (event) => {
  const notification = JSON.parse(event.data);
  showNotification(notification);
});

fetchSSE.addEventListener('error', (event) => {
  console.error('SSE Error:', event.error);
});

fetchSSE.connect();
```

#### Server-Side SSE Examples
```javascript
// Node.js/Express server example
// app.get('/api/stream', (req, res) => {
//   res.writeHead(200, {
//     'Content-Type': 'text/event-stream',
//     'Cache-Control': 'no-cache',
//     'Connection': 'keep-alive',
//     'Access-Control-Allow-Origin': '*',
//     'Access-Control-Allow-Headers': 'Authorization'
//   });
//   
//   // Send initial connection message
//   res.write('data: Connected to SSE stream\n\n');
//   
//   // Send periodic updates
//   const interval = setInterval(() => {
//     const data = {
//       timestamp: new Date().toISOString(),
//       message: 'Periodic update',
//       value: Math.random()
//     };
//     
//     res.write(`data: ${JSON.stringify(data)}\n\n`);
//   }, 5000);
//   
//   // Send custom events
//   setTimeout(() => {
//     res.write('event: notification\n');
//     res.write('data: {"type": "info", "message": "Welcome!"}\n\n');
//   }, 1000);
//   
//   // Handle client disconnect
//   req.on('close', () => {
//     clearInterval(interval);
//     console.log('Client disconnected');
//   });
// });

// SSE message format examples:
// Basic message: data: Hello World\n\n
// JSON message: data: {"key": "value"}\n\n
// Custom event: event: user-joined\ndata: {"name": "John"}\n\n
// With ID: id: 123\ndata: Message with ID\n\n
// Multi-line: data: Line 1\ndata: Line 2\n\n
```

#### Advanced SSE Patterns
```javascript
// SSE with automatic reconnection and state management
class RobustSSE {
  constructor(url, options = {}) {
    this.url = url;
    this.options = options;
    this.eventSource = null;
    this.listeners = new Map();
    this.state = 'disconnected'; // disconnected, connecting, connected
    this.lastEventId = null;
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = options.maxReconnectAttempts || 10;
    this.reconnectDelay = options.reconnectDelay || 1000;
    this.heartbeatInterval = options.heartbeatInterval || 30000;
    this.heartbeatTimer = null;
  }
  
  connect() {
    if (this.state === 'connecting' || this.state === 'connected') {
      return;
    }
    
    this.state = 'connecting';
    this.emit('connecting');
    
    // Include last event ID for resuming from where we left off
    const url = new URL(this.url);
    if (this.lastEventId) {
      url.searchParams.set('lastEventId', this.lastEventId);
    }
    
    this.eventSource = new EventSource(url.toString());
    
    this.eventSource.onopen = () => {
      this.state = 'connected';
      this.reconnectAttempts = 0;
      this.startHeartbeat();
      this.emit('connected');
    };
    
    this.eventSource.onmessage = (event) => {
      this.lastEventId = event.lastEventId;
      this.resetHeartbeat();
      this.emit('message', event);
    };
    
    this.eventSource.onerror = (event) => {
      this.state = 'disconnected';
      this.stopHeartbeat();
      this.emit('error', event);
      this.handleReconnect();
    };
    
    // Restore custom listeners
    this.listeners.forEach((handlers, eventType) => {
      if (eventType !== 'connecting' && eventType !== 'connected' && 
          eventType !== 'disconnected' && eventType !== 'error') {
        handlers.forEach(handler => {
          this.eventSource.addEventListener(eventType, handler);
        });
      }
    });
  }
  
  startHeartbeat() {
    this.heartbeatTimer = setInterval(() => {
      if (this.state === 'connected') {
        // Send a fetch request to check if server is still alive
        fetch(this.url.replace('/stream', '/heartbeat'), { method: 'HEAD' })
          .catch(() => {
            console.log('Heartbeat failed, reconnecting...');
            this.reconnect();
          });
      }
    }, this.heartbeatInterval);
  }
  
  stopHeartbeat() {
    if this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = null;
    }
  }
  
  resetHeartbeat() {
    this.stopHeartbeat();
    this.startHeartbeat();
  }
  
  handleReconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);
      
      console.log(`Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts})`);
      
      setTimeout(() => {
        this.reconnect();
      }, delay);
    } else {
      this.state = 'disconnected';
      this.emit('disconnected', { reason: 'max_reconnect_attempts_reached' });
    }
  }
  
  reconnect() {
    this.close();
    this.connect();
  }
  
  addEventListener(eventType, handler) {
    if (!this.listeners.has(eventType)) {
      this.listeners.set(eventType, []);
    }
    this.listeners.get(eventType).push(handler);
    
    if (this.eventSource && eventType !== 'connecting' && eventType !== 'connected' && 
        eventType !== 'disconnected' && eventType !== 'error') {
      this.eventSource.addEventListener(eventType, handler);
    }
  }
  
  removeEventListener(eventType, handler) {
    const handlers = this.listeners.get(eventType);
    if (handlers) {
      const index = handlers.indexOf(handler);
      if (index > -1) {
        handlers.splice(index, 1);
      }
    }
  }
  
  emit(eventType, data = null) {
    const handlers = this.listeners.get(eventType);
    if (handlers) {
      handlers.forEach(handler => {
        try {
          handler(data);
        } catch (error) {
          console.error(`Error in ${eventType} handler:`, error);
        }
      });
    }
  }
  
  close() {
    this.state = 'disconnected';
    this.stopHeartbeat();
    if (this.eventSource) {
      this.eventSource.close();
      this.eventSource = null;
    }
    this.emit('disconnected', { reason: 'manual_close' });
  }
  
  getState() {
    return this.state;
  }
}

// Usage
const robustSSE = new RobustSSE('/api/stream', {
  maxReconnectAttempts: 5,
  reconnectDelay: 2000,
  heartbeatInterval: 30000
});

robustSSE.addEventListener('connecting', () => {
  console.log('Connecting to SSE...');
  showStatus('Connecting...');
});

robustSSE.addEventListener('connected', () => {
  console.log('SSE connected successfully');
  showStatus('Connected');
});

robustSSE.addEventListener('disconnected', (data) => {
  console.log('SSE disconnected:', data.reason);
  showStatus('Disconnected');
});

robustSSE.addEventListener('message', (event) => {
  const data = JSON.parse(event.data);
  updateUI(data);
});

robustSSE.addEventListener('notification', (event) => {
  const notification = JSON.parse(event.data);
  showNotification(notification.message, notification.type);
});

robustSSE.connect();
```

#### SSE vs WebSockets vs Polling
```javascript
// Comparison of real-time communication methods

// 1. Server-Sent Events (SSE)
// Pros: Simple, automatic reconnection, works with existing HTTP infrastructure
// Cons: Unidirectional (server to client only), limited by browser connection limits
// Use cases: Live feeds, notifications, real-time dashboards

const sseExample = {
  // Client code
  eventSource: new EventSource('/api/live-feed'),
  
  setup() {
    this.eventSource.onmessage = (event) => {
      const data = JSON.parse(event.data);
      updateDashboard(data);
    };
  }
};

// 2. WebSockets
// Pros: Bidirectional, low latency, full-duplex communication
// Cons: More complex, requires WebSocket server, doesn't work through all proxies
// Use cases: Chat applications, real-time gaming, collaborative editing

const wsExample = {
  // Client code
  websocket: new WebSocket('ws://localhost:8080'),
  
  setup() {
    this.websocket.onmessage = (event) => {
      const data = JSON.parse(event.data);
      handleMessage(data);
    };
    
    this.websocket.send(JSON.stringify({ type: 'join', room: 'chat1' }));
  }
};

// 3. Polling with Fetch
// Pros: Simple, works everywhere, easy to implement
// Cons: Higher latency, more server load, not truly real-time
// Use cases: Status updates, periodic data refresh

const pollingExample = {
  interval: null,
  
  startPolling() {
    this.interval = setInterval(async () => {
      try {
        const response = await fetch('/api/status');
        const data = await response.json();
        updateStatus(data);
      } catch (error) {
        console.error('Polling error:', error);
      }
    }, 5000); // Poll every 5 seconds
  },
  
  stopPolling() {
    if (this.interval) {
      clearInterval(this.interval);
      this.interval = null;
    }
  }
};

// 4. Long Polling with Fetch
// Pros: Near real-time, works with HTTP, better than regular polling
// Cons: Complex error handling, can timeout, server resource intensive
// Use cases: When WebSockets aren't available but real-time is needed

const longPollingExample = {
  isPolling: false,
  
  async startLongPolling() {
    this.isPolling = true;
    
    while (this.isPolling) {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 30000); // 30s timeout
        
        const response = await fetch('/api/long-poll', {
          signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        if (response.ok) {
          const data = await response.json();
          handleUpdate(data);
        }
      } catch (error) {
        if (error.name === 'AbortError') {
          console.log('Long poll timeout, restarting...');
        } else {
          console.error('Long polling error:', error);
          await new Promise(resolve => setTimeout(resolve, 5000)); // Wait 5s before retry
        }
      }
    }
  },
  
  stopLongPolling() {
    this.isPolling = false;
  }
};
```

---
