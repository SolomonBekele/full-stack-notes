# DOM & DOM Events Guide

## Table of Contents
1. [What is the DOM?](#what-is-the-dom)
2. [DOM Structure](#dom-structure)
3. [Accessing DOM Elements](#accessing-dom-elements)
4. [Manipulating the DOM](#manipulating-the-dom)
5. [DOM Events](#dom-events)
6. [Event Delegation](#event-delegation)
7. [MutationObserver](#mutationobserver)
8. [Custom Events](#custom-events)
9. [Shadow DOM](#shadow-dom)
10. [Event Propagation](#event-propagation)
11. [Performance Optimization](#performance-optimization)
13. [Best Practices](#best-practices)

---

## What is the DOM?
The Document Object Model (DOM) is a programming interface for HTML and XML documents. It represents the page so that programs can change the document structure, style, and content.
- The DOM is a tree of nodes (elements, text, attributes).
- Each HTML element is represented as an object.

---

## DOM Structure
- The root node is `document`.
- Elements are nested as parent and child nodes.

Example:
```html
<html>
  <body>
    <div id="container">
      <p>Hello World</p>
    </div>
  </body>
</html>
```

---

## Accessing DOM Elements
### By ID
```javascript
document.getElementById('container');
```
### By Class Name
```javascript
document.getElementsByClassName('my-class');
```
### By Tag Name
```javascript
document.getElementsByTagName('div');
```
### By Query Selector
```javascript
document.querySelector('.my-class');
document.querySelectorAll('div > p');
```

---

## Manipulating the DOM
### Changing Content
```javascript
const el = document.getElementById('container');
el.textContent = 'New Content';
```
### Changing Attributes
```javascript
el.setAttribute('data-id', '123');
```
### Changing Styles
```javascript
el.style.backgroundColor = 'yellow';
```
### Creating and Removing Elements
```javascript
const newDiv = document.createElement('div');
document.body.appendChild(newDiv);
document.body.removeChild(newDiv);
```

---

## DOM Events
Events are actions that happen in the browser (clicks, key presses, etc.).
### Adding Event Listeners
```javascript
const btn = document.getElementById('myBtn');
btn.addEventListener('click', function() {
  alert('Button clicked!');
});
```
### Common Event Types
- `click`
- `change`
- `input`
- `submit`
- `keydown`, `keyup`
- `mouseover`, `mouseout`
### Removing Event Listeners
```javascript
function handler() { /* ... */ }
btn.addEventListener('click', handler);
btn.removeEventListener('click', handler);
```

---

## Event Delegation
Event delegation leverages event bubbling to handle events for multiple child elements with a single parent listener. Instead of attaching listeners to each child, you attach one to the parent and use `event.target` to determine which child triggered the event. This is efficient for dynamic lists or elements created at runtime, reducing memory usage and improving performance.

Example:
```html
<ul id="list">
  <li>Item 1</li>
  <li>Item 2</li>
  <li>Item 3</li>
</ul>
```
```javascript
document.getElementById('list').addEventListener('click', function(e) {
  if (e.target.tagName === 'LI') {
    alert('List item clicked: ' + e.target.textContent);
  }
});
```

---

## MutationObserver
MutationObserver lets you watch for changes in the DOM tree (attributes, child nodes, etc.).
```javascript
const observer = new MutationObserver((mutations) => {
  mutations.forEach(mutation => {
    console.log(mutation);
  });
});
observer.observe(document.getElementById('container'), { childList: true, subtree: true });
```

---

## Custom Events
Custom events allow you to define and dispatch your own event types, enabling decoupled communication between components. You create a custom event using `new CustomEvent('eventName', { detail: { ... } })` and dispatch it with `dispatchEvent`. Listeners can respond to these events just like built-in ones. This is useful for building modular, reusable components.

Example:
```javascript
// Create and dispatch a custom event
document.addEventListener('userLoggedIn', function(e) {
  console.log('User logged in:', e.detail.username);
});

const loginEvent = new CustomEvent('userLoggedIn', { detail: { username: 'alice' } });
document.dispatchEvent(loginEvent);
```

---

## Shadow DOM
Shadow DOM is a web standard for encapsulating a component’s internal DOM and styles, preventing them from leaking out or being affected by external CSS. You create a shadow root with `element.attachShadow({ mode: 'open' })` and add markup/styles inside it. This is essential for building custom elements (Web Components) that are truly isolated and maintainable.

Example:
```html
<div id="shadow-host"></div>
```
```javascript
const host = document.getElementById('shadow-host');
const shadow = host.attachShadow({ mode: 'open' });
shadow.innerHTML = `
  <style>p { color: blue; }</style>
  <p>This is inside the Shadow DOM!</p>
`;
```

If your app or system:
- Has shared components across multiple teams/frameworks
- Needs CSS isolation and reusable UI
- Embeds components on external sites or micro frontends

➡️ Then Shadow DOM is your best architectural choice.

---

## Event Propagation
Events propagate in two phases: capturing (top-down) and bubbling (bottom-up).
```javascript
document.getElementById('container').addEventListener('click', handler, true); // Capturing
document.getElementById('container').addEventListener('click', handler, false); // Bubbling
```

---

## Performance Optimization
- Minimize reflows and repaints by batching DOM changes.
- Use `documentFragment` for bulk DOM insertions.
- Avoid layout thrashing (reading and writing layout properties in rapid succession).

---

## Best Practices
1. Minimize direct DOM manipulation for performance.
2. Use event delegation for dynamic lists.
3. Clean up event listeners to avoid memory leaks.
4. Prefer `textContent` over `innerHTML` for security.
5. Test across browsers for compatibility.

---

## Practice Section: DOM & Events for Your Portfolio

Apply these concepts to your personal portfolio page using HTML, CSS, and vanilla JavaScript:

1. **Event Delegation**
   - Add a navigation menu or list of project cards.
   - Use event delegation to handle clicks on menu items or cards, showing details or highlighting the selection.

2. **Custom Events**
   - Add an option (e.g., "Add New Section") to your portfolio.
   - When the user clicks this option, dispatch a custom event (e.g., `sectionAdded`).
   - Listen for the `sectionAdded` event and dynamically add a new section to your portfolio page.
   - Ensure the new section also appears in the side navigation menu, updating it in response to the event.

3. **Shadow DOM**
   - Build a custom element (e.g., `<date-picker>`) for your certification section.
   - A simple grid which shows calender as shadow dom.

4. **MutationObserver**
   - Monitor changes to your portfolio’s project list (e.g., when adding/removing projects dynamically).
   - Log or react to these changes for analytics or UI updates.

---

Try implementing these features in your portfolio to reinforce your understanding and build practical frontend skills.

---

This guide covers the essentials and advanced concepts of the DOM and DOM events, including structure, access, manipulation, event handling, optimization, and best practices for interactive web applications.
